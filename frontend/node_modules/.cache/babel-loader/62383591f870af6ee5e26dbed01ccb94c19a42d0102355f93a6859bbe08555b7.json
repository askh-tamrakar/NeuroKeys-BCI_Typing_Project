{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\akmor\\\\OneDrive\\\\Projects\\\\website\\\\src\\\\components\\\\EncryptText.js\",\n  _s = $RefreshSig$();\n// src/components/EncryptText.js\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { motion } from 'motion/react';\nimport PropTypes from 'prop-types';\nimport './EncryptText.css';\n\n/**\r\n * EncryptText\r\n * - Hover to scramble (encrypt). Leave to revert (decrypt).\r\n * - Supports sequential (progressive) scrambling and directional order.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EncryptText = ({\n  text,\n  speed = 40,\n  maxIterations = 12,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\n  className = 'encrypt-text',\n  encryptedClassName = 'encrypted',\n  sequential = false,\n  direction = 'start',\n  // 'start' | 'end' | 'center'\n  ...props\n}) => {\n  _s();\n  const [displayText, setDisplayText] = useState(text);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  // Holds order of indices when sequentially scrambling so we can reverse correctly\n  const orderRef = useRef([]);\n  // Tracks which indices are currently scrambled (Set for O(1) checks)\n  const scrambledSetRef = useRef(new Set());\n  // interval handle\n  const intervalRef = useRef(null);\n\n  // memoized chars array\n  const charsArray = useRef(characters.split(''));\n  useEffect(() => {\n    charsArray.current = characters.split('');\n  }, [characters]);\n\n  // Helper: get next index to scramble based on direction and already-chosen order\n  const getNextIndexToScramble = useCallback(chosenSet => {\n    const textLength = text.length;\n\n    // helper to find first unchosen scanning from left->right\n    const firstUnchosen = () => {\n      for (let i = 0; i < textLength; i++) if (!chosenSet.has(i) && text[i] !== ' ') return i;\n      return -1;\n    };\n    if (direction === 'start') {\n      // left to right: choose smallest index not chosen\n      for (let i = 0; i < textLength; i++) {\n        if (!chosenSet.has(i) && text[i] !== ' ') return i;\n      }\n      return -1;\n    }\n    if (direction === 'end') {\n      // right to left: choose largest index not chosen\n      for (let i = textLength - 1; i >= 0; i--) {\n        if (!chosenSet.has(i) && text[i] !== ' ') return i;\n      }\n      return -1;\n    }\n\n    // center-out\n    const middle = Math.floor(textLength / 2);\n    // attempt offsets increasing\n    for (let offset = 0; offset < textLength; offset++) {\n      const idx1 = middle + offset;\n      if (idx1 < textLength && !chosenSet.has(idx1) && text[idx1] !== ' ') return idx1;\n      const idx2 = middle - offset - 1;\n      if (idx2 >= 0 && !chosenSet.has(idx2) && text[idx2] !== ' ') return idx2;\n    }\n    // fallback\n    return firstUnchosen();\n  }, [direction, text]);\n\n  // scramble helper (non-sequential): replace non-space chars with randoms\n  const scrambleAll = useCallback(source => {\n    const chars = charsArray.current;\n    return source.split('').map(ch => ch === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]).join('');\n  }, []);\n\n  // build text based on scrambledSetRef (for sequential mode)\n  const buildFromScrambledSet = useCallback(() => {\n    const s = scrambledSetRef.current;\n    const chars = charsArray.current;\n    return text.split('').map((ch, i) => {\n      if (ch === ' ') return ' ';\n      if (s.has(i)) {\n        return chars[Math.floor(Math.random() * chars.length)];\n      }\n      return ch;\n    }).join('');\n  }, [text]);\n  useEffect(() => {\n    // cleanup before starting\n    clearInterval(intervalRef.current);\n\n    // Reset order and set if text changes\n    orderRef.current = [];\n    scrambledSetRef.current = new Set();\n    setDisplayText(text);\n    setIsAnimating(false);\n    return () => clearInterval(intervalRef.current);\n  }, [text]);\n  useEffect(() => {\n    // main animation loop\n    clearInterval(intervalRef.current);\n    let iteration = 0;\n    if (isHovering) {\n      // ENCRYPT: scramble progressively or randomly until fully scrambled\n      setIsAnimating(true);\n      if (sequential) {\n        // sequential: add one index per tick (or more if you prefer)\n        intervalRef.current = setInterval(() => {\n          const s = scrambledSetRef.current;\n          const next = getNextIndexToScramble(s);\n          if (next === -1) {\n            // nothing left to scramble\n            setDisplayText(scrambleAll(text));\n            clearInterval(intervalRef.current);\n            return;\n          }\n          // mark chosen\n          s.add(next);\n          orderRef.current.push(next);\n          setDisplayText(buildFromScrambledSet());\n          // stop when all non-space characters are scrambled\n          const allScrambled = text.split('').every((ch, i) => ch === ' ' || s.has(i));\n          if (allScrambled) {\n            clearInterval(intervalRef.current);\n          }\n        }, speed);\n      } else {\n        // non-sequential: randomize whole text each tick; after maxIterations set to final scrambled state\n        intervalRef.current = setInterval(() => {\n          setDisplayText(scrambleAll(text));\n          iteration++;\n          if (iteration >= maxIterations) {\n            clearInterval(intervalRef.current);\n            // final scrambled appearance (fully scrambled)\n            setDisplayText(scrambleAll(text));\n          }\n        }, speed);\n      }\n    } else {\n      // DECRYPT: revert progressively or set to original after a few iterations\n      setIsAnimating(true);\n      if (sequential) {\n        // sequential: remove indices in reverse order of addition\n        intervalRef.current = setInterval(() => {\n          const order = orderRef.current;\n          const s = scrambledSetRef.current;\n          if (order.length === 0) {\n            // nothing left, restore original and stop\n            setDisplayText(text);\n            setIsAnimating(false);\n            clearInterval(intervalRef.current);\n            return;\n          }\n          // pop last added index and remove from set (revealing original)\n          const last = order.pop();\n          s.delete(last);\n          setDisplayText(buildFromScrambledSet());\n        }, speed);\n      } else {\n        // non-sequential: randomize a few times then set back to original\n        intervalRef.current = setInterval(() => {\n          iteration++;\n          if (iteration >= Math.ceil(maxIterations / 2)) {\n            setDisplayText(text);\n            setIsAnimating(false);\n            clearInterval(intervalRef.current);\n          } else {\n            setDisplayText(scrambleAll(text));\n          }\n        }, speed);\n      }\n    }\n    return () => {\n      clearInterval(intervalRef.current);\n    };\n  }, [isHovering, speed, maxIterations, sequential, scrambleAll, getNextIndexToScramble, buildFromScrambledSet, text]);\n  return /*#__PURE__*/_jsxDEV(motion.span, {\n    className: `wrapper ${className}`,\n    onMouseEnter: () => setIsHovering(true),\n    onMouseLeave: () => setIsHovering(false),\n    ...props,\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"srOnly\",\n      \"aria-hidden\": \"true\",\n      children: text\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      \"aria-hidden\": \"true\",\n      children: displayText.split('').map((char, i) => {\n        // when animating and currently scrambling, show encrypted class, otherwise regular class\n        const currentlyEncrypted = isAnimating && (sequential ? scrambledSetRef.current.has(i) : isHovering);\n        const usedClass = currentlyEncrypted ? encryptedClassName : className;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: usedClass,\n          style: {\n            transition: 'color 0.25s ease'\n          },\n          children: char\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 224,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 218,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 208,\n    columnNumber: 5\n  }, this);\n};\n_s(EncryptText, \"/8zgfqc6lVYSUN4aM8U3AiqQI7A=\");\n_c = EncryptText;\nEncryptText.propTypes = {\n  text: PropTypes.string.isRequired,\n  speed: PropTypes.number,\n  maxIterations: PropTypes.number,\n  characters: PropTypes.string,\n  className: PropTypes.string,\n  encryptedClassName: PropTypes.string,\n  sequential: PropTypes.bool,\n  direction: PropTypes.oneOf(['start', 'end', 'center'])\n};\nexport default EncryptText;\nvar _c;\n$RefreshReg$(_c, \"EncryptText\");","map":{"version":3,"names":["React","useCallback","useEffect","useRef","useState","motion","PropTypes","jsxDEV","_jsxDEV","EncryptText","text","speed","maxIterations","characters","className","encryptedClassName","sequential","direction","props","_s","displayText","setDisplayText","isHovering","setIsHovering","isAnimating","setIsAnimating","orderRef","scrambledSetRef","Set","intervalRef","charsArray","split","current","getNextIndexToScramble","chosenSet","textLength","length","firstUnchosen","i","has","middle","Math","floor","offset","idx1","idx2","scrambleAll","source","chars","map","ch","random","join","buildFromScrambledSet","s","clearInterval","iteration","setInterval","next","add","push","allScrambled","every","order","last","pop","delete","ceil","span","onMouseEnter","onMouseLeave","children","fileName","_jsxFileName","lineNumber","columnNumber","char","currentlyEncrypted","usedClass","style","transition","_c","propTypes","string","isRequired","number","bool","oneOf","$RefreshReg$"],"sources":["C:/Users/akmor/OneDrive/Projects/website/src/components/EncryptText.js"],"sourcesContent":["// src/components/EncryptText.js\r\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { motion } from 'motion/react';\r\nimport PropTypes from 'prop-types';\r\nimport './EncryptText.css';\r\n\r\n/**\r\n * EncryptText\r\n * - Hover to scramble (encrypt). Leave to revert (decrypt).\r\n * - Supports sequential (progressive) scrambling and directional order.\r\n */\r\nconst EncryptText = ({\r\n  text,\r\n  speed = 40,\r\n  maxIterations = 12,\r\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\r\n  className = 'encrypt-text',\r\n  encryptedClassName = 'encrypted',\r\n  sequential = false,\r\n  direction = 'start', // 'start' | 'end' | 'center'\r\n  ...props\r\n}) => {\r\n  const [displayText, setDisplayText] = useState(text);\r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n\r\n  // Holds order of indices when sequentially scrambling so we can reverse correctly\r\n  const orderRef = useRef([]);\r\n  // Tracks which indices are currently scrambled (Set for O(1) checks)\r\n  const scrambledSetRef = useRef(new Set());\r\n  // interval handle\r\n  const intervalRef = useRef(null);\r\n\r\n  // memoized chars array\r\n  const charsArray = useRef(characters.split(''));\r\n\r\n  useEffect(() => {\r\n    charsArray.current = characters.split('');\r\n  }, [characters]);\r\n\r\n  // Helper: get next index to scramble based on direction and already-chosen order\r\n  const getNextIndexToScramble = useCallback(\r\n    (chosenSet) => {\r\n      const textLength = text.length;\r\n\r\n      // helper to find first unchosen scanning from left->right\r\n      const firstUnchosen = () => {\r\n        for (let i = 0; i < textLength; i++) if (!chosenSet.has(i) && text[i] !== ' ') return i;\r\n        return -1;\r\n      };\r\n\r\n      if (direction === 'start') {\r\n        // left to right: choose smallest index not chosen\r\n        for (let i = 0; i < textLength; i++) {\r\n          if (!chosenSet.has(i) && text[i] !== ' ') return i;\r\n        }\r\n        return -1;\r\n      }\r\n\r\n      if (direction === 'end') {\r\n        // right to left: choose largest index not chosen\r\n        for (let i = textLength - 1; i >= 0; i--) {\r\n          if (!chosenSet.has(i) && text[i] !== ' ') return i;\r\n        }\r\n        return -1;\r\n      }\r\n\r\n      // center-out\r\n      const middle = Math.floor(textLength / 2);\r\n      // attempt offsets increasing\r\n      for (let offset = 0; offset < textLength; offset++) {\r\n        const idx1 = middle + offset;\r\n        if (idx1 < textLength && !chosenSet.has(idx1) && text[idx1] !== ' ') return idx1;\r\n        const idx2 = middle - offset - 1;\r\n        if (idx2 >= 0 && !chosenSet.has(idx2) && text[idx2] !== ' ') return idx2;\r\n      }\r\n      // fallback\r\n      return firstUnchosen();\r\n    },\r\n    [direction, text]\r\n  );\r\n\r\n  // scramble helper (non-sequential): replace non-space chars with randoms\r\n  const scrambleAll = useCallback(\r\n    (source) => {\r\n      const chars = charsArray.current;\r\n      return source\r\n        .split('')\r\n        .map((ch) => (ch === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]))\r\n        .join('');\r\n    },\r\n    []\r\n  );\r\n\r\n  // build text based on scrambledSetRef (for sequential mode)\r\n  const buildFromScrambledSet = useCallback(() => {\r\n    const s = scrambledSetRef.current;\r\n    const chars = charsArray.current;\r\n    return text\r\n      .split('')\r\n      .map((ch, i) => {\r\n        if (ch === ' ') return ' ';\r\n        if (s.has(i)) {\r\n          return chars[Math.floor(Math.random() * chars.length)];\r\n        }\r\n        return ch;\r\n      })\r\n      .join('');\r\n  }, [text]);\r\n\r\n  useEffect(() => {\r\n    // cleanup before starting\r\n    clearInterval(intervalRef.current);\r\n\r\n    // Reset order and set if text changes\r\n    orderRef.current = [];\r\n    scrambledSetRef.current = new Set();\r\n    setDisplayText(text);\r\n    setIsAnimating(false);\r\n\r\n    return () => clearInterval(intervalRef.current);\r\n  }, [text]);\r\n\r\n  useEffect(() => {\r\n    // main animation loop\r\n    clearInterval(intervalRef.current);\r\n    let iteration = 0;\r\n\r\n    if (isHovering) {\r\n      // ENCRYPT: scramble progressively or randomly until fully scrambled\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // sequential: add one index per tick (or more if you prefer)\r\n        intervalRef.current = setInterval(() => {\r\n          const s = scrambledSetRef.current;\r\n          const next = getNextIndexToScramble(s);\r\n          if (next === -1) {\r\n            // nothing left to scramble\r\n            setDisplayText(scrambleAll(text));\r\n            clearInterval(intervalRef.current);\r\n            return;\r\n          }\r\n          // mark chosen\r\n          s.add(next);\r\n          orderRef.current.push(next);\r\n          setDisplayText(buildFromScrambledSet());\r\n          // stop when all non-space characters are scrambled\r\n          const allScrambled = text.split('').every((ch, i) => ch === ' ' || s.has(i));\r\n          if (allScrambled) {\r\n            clearInterval(intervalRef.current);\r\n          }\r\n        }, speed);\r\n      } else {\r\n        // non-sequential: randomize whole text each tick; after maxIterations set to final scrambled state\r\n        intervalRef.current = setInterval(() => {\r\n          setDisplayText(scrambleAll(text));\r\n          iteration++;\r\n          if (iteration >= maxIterations) {\r\n            clearInterval(intervalRef.current);\r\n            // final scrambled appearance (fully scrambled)\r\n            setDisplayText(scrambleAll(text));\r\n          }\r\n        }, speed);\r\n      }\r\n    } else {\r\n      // DECRYPT: revert progressively or set to original after a few iterations\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // sequential: remove indices in reverse order of addition\r\n        intervalRef.current = setInterval(() => {\r\n          const order = orderRef.current;\r\n          const s = scrambledSetRef.current;\r\n          if (order.length === 0) {\r\n            // nothing left, restore original and stop\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n            clearInterval(intervalRef.current);\r\n            return;\r\n          }\r\n          // pop last added index and remove from set (revealing original)\r\n          const last = order.pop();\r\n          s.delete(last);\r\n          setDisplayText(buildFromScrambledSet());\r\n        }, speed);\r\n      } else {\r\n        // non-sequential: randomize a few times then set back to original\r\n        intervalRef.current = setInterval(() => {\r\n          iteration++;\r\n          if (iteration >= Math.ceil(maxIterations / 2)) {\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n            clearInterval(intervalRef.current);\r\n          } else {\r\n            setDisplayText(scrambleAll(text));\r\n          }\r\n        }, speed);\r\n      }\r\n    }\r\n\r\n    return () => {\r\n      clearInterval(intervalRef.current);\r\n    };\r\n  }, [isHovering, speed, maxIterations, sequential, scrambleAll, getNextIndexToScramble, buildFromScrambledSet, text]);\r\n\r\n  return (\r\n    <motion.span\r\n      className={`wrapper ${className}`}\r\n      onMouseEnter={() => setIsHovering(true)}\r\n      onMouseLeave={() => setIsHovering(false)}\r\n      {...props}\r\n    >\r\n      <span className=\"srOnly\" aria-hidden=\"true\">\r\n        {text}\r\n      </span>\r\n\r\n      <span aria-hidden=\"true\">\r\n        {displayText.split('').map((char, i) => {\r\n          // when animating and currently scrambling, show encrypted class, otherwise regular class\r\n          const currentlyEncrypted = isAnimating && (sequential ? scrambledSetRef.current.has(i) : isHovering);\r\n          const usedClass = currentlyEncrypted ? encryptedClassName : className;\r\n          return (\r\n            <span key={i} className={usedClass} style={{ transition: 'color 0.25s ease' }}>\r\n              {char}\r\n            </span>\r\n          );\r\n        })}\r\n      </span>\r\n    </motion.span>\r\n  );\r\n};\r\n\r\nEncryptText.propTypes = {\r\n  text: PropTypes.string.isRequired,\r\n  speed: PropTypes.number,\r\n  maxIterations: PropTypes.number,\r\n  characters: PropTypes.string,\r\n  className: PropTypes.string,\r\n  encryptedClassName: PropTypes.string,\r\n  sequential: PropTypes.bool,\r\n  direction: PropTypes.oneOf(['start', 'end', 'center'])\r\n};\r\n\r\nexport default EncryptText;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}