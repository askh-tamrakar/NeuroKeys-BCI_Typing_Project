{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\akmor\\\\OneDrive\\\\Projects\\\\website\\\\src\\\\components\\\\EncryptText.js\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { motion } from 'motion/react';\nimport PropTypes from 'prop-types';\nimport './EncryptText.css';\n\n/**\r\n * EncryptText\r\n * - Hover to scramble (encrypt). Leave to revert (decrypt).\r\n * - Supports sequential (progressive) scrambling and directional order.\r\n * - Supports independent directions for encryption and decryption.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EncryptText = ({\n  text,\n  speed = 40,\n  maxIterations = 12,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\n  className = 'encrypt-text',\n  encryptedClassName = 'encrypted',\n  sequential = false,\n  encryptDirection = 'start',\n  // 'start' | 'end' | 'center'\n  decryptDirection = 'start',\n  // 'start' | 'end' | 'center'\n  ...props\n}) => {\n  _s();\n  const [displayText, setDisplayText] = useState(text);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  // refs to manage state across intervals without causing re-renders\n  const scrambledSetRef = useRef(new Set()); // indices that are currently scrambled\n  const intervalRef = useRef(null);\n  const charsArrayRef = useRef(characters.split(''));\n  const encryptOrderRef = useRef([]); // full index order used for sequential encrypt\n  const decryptOrderRef = useRef([]); // full index order used for sequential decrypt\n  const encryptPointerRef = useRef(0); // how many indices we've scrambled (pointer into encryptOrder)\n  const decryptPointerRef = useRef(0); // how many indices we've revealed during decrypt (pointer into decryptOrder)\n\n  // Keep character array updated if characters prop changes\n  useEffect(() => {\n    charsArrayRef.current = characters.split('');\n  }, [characters]);\n\n  // utility: returns array of indices (non-space) in order for a given direction\n  const computeOrderForDirection = useCallback(dir => {\n    const len = text.length;\n    const indices = [];\n    for (let i = 0; i < len; i++) if (text[i] !== ' ') indices.push(i);\n    if (dir === 'start') {\n      return indices; // left-to-right\n    }\n    if (dir === 'end') {\n      return indices.reverse(); // right-to-left\n    }\n    // center\n    const out = [];\n    const middle = Math.floor(len / 2);\n    // create array of non-space indices and then pick center-out\n    const candidates = indices.slice();\n    // pick by proximity to middle, prefer right first (so center then right then left)\n    while (candidates.length) {\n      let closestIndex = -1;\n      let closestDist = Infinity;\n      for (let idx of candidates) {\n        const dist = Math.abs(idx - middle);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestIndex = idx;\n        } else if (dist === closestDist) {\n          // tie-breaker: pick the higher index first (center-right preference)\n          if (idx > closestIndex) closestIndex = idx;\n        }\n      }\n      out.push(closestIndex);\n      const removeIdx = candidates.indexOf(closestIndex);\n      if (removeIdx !== -1) candidates.splice(removeIdx, 1);\n    }\n    return out;\n  }, [text]);\n\n  // scramble all non-space chars randomly\n  const scrambleAll = useCallback(source => {\n    const chars = charsArrayRef.current;\n    return source.split('').map(ch => ch === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]).join('');\n  }, []);\n\n  // build the current display string from scrambledSetRef (for sequential mode)\n  const buildFromScrambledSet = useCallback(() => {\n    const s = scrambledSetRef.current;\n    const chars = charsArrayRef.current;\n    return text.split('').map((ch, i) => {\n      if (ch === ' ') return ' ';\n      if (s.has(i)) {\n        return chars[Math.floor(Math.random() * chars.length)];\n      }\n      return ch;\n    }).join('');\n  }, [text]);\n\n  // when text changes, recompute orders and reset state\n  useEffect(() => {\n    clearInterval(intervalRef.current);\n    scrambledSetRef.current = new Set();\n    encryptOrderRef.current = computeOrderForDirection(encryptDirection);\n    decryptOrderRef.current = computeOrderForDirection(decryptDirection);\n    encryptPointerRef.current = 0;\n    decryptPointerRef.current = 0;\n    setDisplayText(text);\n    setIsAnimating(false);\n    return () => clearInterval(intervalRef.current);\n  }, [text, computeOrderForDirection, encryptDirection, decryptDirection]);\n\n  // main animation effect\n  useEffect(() => {\n    clearInterval(intervalRef.current);\n    let iteration = 0;\n    if (isHovering) {\n      // ENCRYPT\n      setIsAnimating(true);\n      if (sequential) {\n        // sequential encryption: step through encryptOrderRef\n        intervalRef.current = setInterval(() => {\n          const order = encryptOrderRef.current;\n          const ptr = encryptPointerRef.current;\n          if (ptr >= order.length) {\n            // fully scrambled\n            setDisplayText(scrambleAll(text));\n            clearInterval(intervalRef.current);\n            return;\n          }\n          const idx = order[ptr];\n          scrambledSetRef.current.add(idx);\n          encryptPointerRef.current = ptr + 1;\n          setDisplayText(buildFromScrambledSet());\n\n          // Stop when all non-space indices scrambled\n          if (encryptPointerRef.current >= order.length) {\n            clearInterval(intervalRef.current);\n          }\n        }, speed);\n      } else {\n        // non-sequential: randomize whole text each tick, stop after maxIterations\n        intervalRef.current = setInterval(() => {\n          setDisplayText(scrambleAll(text));\n          iteration++;\n          if (iteration >= maxIterations) {\n            clearInterval(intervalRef.current);\n            setDisplayText(scrambleAll(text));\n          }\n        }, speed);\n      }\n    } else {\n      // DECRYPT (mouse leave)\n      setIsAnimating(true);\n      if (sequential) {\n        // sequential decryption: reveal indices per decryptOrderRef\n        intervalRef.current = setInterval(() => {\n          const order = decryptOrderRef.current;\n          // find next index in order that is currently scrambled\n          let found = -1;\n          while (decryptPointerRef.current < order.length) {\n            const cand = order[decryptPointerRef.current];\n            decryptPointerRef.current += 1;\n            if (scrambledSetRef.current.has(cand)) {\n              found = cand;\n              break;\n            }\n            // otherwise skip\n          }\n          if (found === -1) {\n            // no scrambled indices left in the rest of order; as fallback, remove any remaining scrambled indices\n            const anyLeft = Array.from(scrambledSetRef.current)[0];\n            if (anyLeft === undefined) {\n              // done\n              setDisplayText(text);\n              setIsAnimating(false);\n              clearInterval(intervalRef.current);\n              return;\n            }\n            scrambledSetRef.current.delete(anyLeft);\n            setDisplayText(buildFromScrambledSet());\n            return;\n          }\n\n          // reveal the found index (i.e., remove from scrambled set)\n          scrambledSetRef.current.delete(found);\n          setDisplayText(buildFromScrambledSet());\n\n          // if no scrambled indices left, finish\n          if (scrambledSetRef.current.size === 0) {\n            setDisplayText(text);\n            setIsAnimating(false);\n            clearInterval(intervalRef.current);\n          }\n        }, speed);\n      } else {\n        // non-sequential decrypt: randomize for a few iterations then reveal final\n        intervalRef.current = setInterval(() => {\n          iteration++;\n          if (iteration >= Math.ceil(maxIterations / 2)) {\n            setDisplayText(text);\n            setIsAnimating(false);\n            clearInterval(intervalRef.current);\n          } else {\n            setDisplayText(scrambleAll(text));\n          }\n        }, speed);\n      }\n    }\n    return () => clearInterval(intervalRef.current);\n  }, [isHovering, speed, maxIterations, sequential, scrambleAll, buildFromScrambledSet, text]);\n  return /*#__PURE__*/_jsxDEV(motion.span, {\n    className: `wrapper ${className}`,\n    onMouseEnter: () => {\n      // reset decrypt pointer so decrypt scanning starts from beginning of decrypt order\n      decryptPointerRef.current = 0;\n      setIsHovering(true);\n    },\n    onMouseLeave: () => {\n      // reset encrypt pointer so encrypt resumes from where it ended (or start)\n      encryptPointerRef.current = Math.min(encryptPointerRef.current, encryptOrderRef.current.length);\n      setIsHovering(false);\n    },\n    ...props,\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"srOnly\",\n      \"aria-hidden\": \"true\",\n      children: text\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      \"aria-hidden\": \"true\",\n      children: displayText.split('').map((char, i) => {\n        const currentlyEncrypted = isAnimating && (sequential ? scrambledSetRef.current.has(i) : isHovering);\n        const usedClass = currentlyEncrypted ? encryptedClassName : className;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: usedClass,\n          style: {\n            transition: 'color 0.25s ease'\n          },\n          children: char\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 256,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n_s(EncryptText, \"tYhZZNqeDjH9xrrTPo8aUWzfnoI=\");\n_c = EncryptText;\nEncryptText.propTypes = {\n  text: PropTypes.string.isRequired,\n  speed: PropTypes.number,\n  maxIterations: PropTypes.number,\n  characters: PropTypes.string,\n  className: PropTypes.string,\n  encryptedClassName: PropTypes.string,\n  sequential: PropTypes.bool,\n  encryptDirection: PropTypes.oneOf(['start', 'end', 'center']),\n  decryptDirection: PropTypes.oneOf(['start', 'end', 'center'])\n};\nexport default EncryptText;\nvar _c;\n$RefreshReg$(_c, \"EncryptText\");","map":{"version":3,"names":["React","useCallback","useEffect","useRef","useState","motion","PropTypes","jsxDEV","_jsxDEV","EncryptText","text","speed","maxIterations","characters","className","encryptedClassName","sequential","encryptDirection","decryptDirection","props","_s","displayText","setDisplayText","isHovering","setIsHovering","isAnimating","setIsAnimating","scrambledSetRef","Set","intervalRef","charsArrayRef","split","encryptOrderRef","decryptOrderRef","encryptPointerRef","decryptPointerRef","current","computeOrderForDirection","dir","len","length","indices","i","push","reverse","out","middle","Math","floor","candidates","slice","closestIndex","closestDist","Infinity","idx","dist","abs","removeIdx","indexOf","splice","scrambleAll","source","chars","map","ch","random","join","buildFromScrambledSet","s","has","clearInterval","iteration","setInterval","order","ptr","add","found","cand","anyLeft","Array","from","undefined","delete","size","ceil","span","onMouseEnter","onMouseLeave","min","children","fileName","_jsxFileName","lineNumber","columnNumber","char","currentlyEncrypted","usedClass","style","transition","_c","propTypes","string","isRequired","number","bool","oneOf","$RefreshReg$"],"sources":["C:/Users/akmor/OneDrive/Projects/website/src/components/EncryptText.js"],"sourcesContent":["\r\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { motion } from 'motion/react';\r\nimport PropTypes from 'prop-types';\r\nimport './EncryptText.css';\r\n\r\n/**\r\n * EncryptText\r\n * - Hover to scramble (encrypt). Leave to revert (decrypt).\r\n * - Supports sequential (progressive) scrambling and directional order.\r\n * - Supports independent directions for encryption and decryption.\r\n */\r\nconst EncryptText = ({\r\n  text,\r\n  speed = 40,\r\n  maxIterations = 12,\r\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\r\n  className = 'encrypt-text',\r\n  encryptedClassName = 'encrypted',\r\n  sequential = false,\r\n  encryptDirection = 'start', // 'start' | 'end' | 'center'\r\n  decryptDirection = 'start', // 'start' | 'end' | 'center'\r\n  ...props\r\n}) => {\r\n  const [displayText, setDisplayText] = useState(text);\r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n\r\n  // refs to manage state across intervals without causing re-renders\r\n  const scrambledSetRef = useRef(new Set()); // indices that are currently scrambled\r\n  const intervalRef = useRef(null);\r\n  const charsArrayRef = useRef(characters.split(''));\r\n  const encryptOrderRef = useRef([]); // full index order used for sequential encrypt\r\n  const decryptOrderRef = useRef([]); // full index order used for sequential decrypt\r\n  const encryptPointerRef = useRef(0); // how many indices we've scrambled (pointer into encryptOrder)\r\n  const decryptPointerRef = useRef(0); // how many indices we've revealed during decrypt (pointer into decryptOrder)\r\n\r\n  // Keep character array updated if characters prop changes\r\n  useEffect(() => {\r\n    charsArrayRef.current = characters.split('');\r\n  }, [characters]);\r\n\r\n  // utility: returns array of indices (non-space) in order for a given direction\r\n  const computeOrderForDirection = useCallback(\r\n    (dir) => {\r\n      const len = text.length;\r\n      const indices = [];\r\n      for (let i = 0; i < len; i++) if (text[i] !== ' ') indices.push(i);\r\n\r\n      if (dir === 'start') {\r\n        return indices; // left-to-right\r\n      }\r\n      if (dir === 'end') {\r\n        return indices.reverse(); // right-to-left\r\n      }\r\n      // center\r\n      const out = [];\r\n      const middle = Math.floor(len / 2);\r\n      // create array of non-space indices and then pick center-out\r\n      const candidates = indices.slice();\r\n      // pick by proximity to middle, prefer right first (so center then right then left)\r\n      while (candidates.length) {\r\n        let closestIndex = -1;\r\n        let closestDist = Infinity;\r\n        for (let idx of candidates) {\r\n          const dist = Math.abs(idx - middle);\r\n          if (dist < closestDist) {\r\n            closestDist = dist;\r\n            closestIndex = idx;\r\n          } else if (dist === closestDist) {\r\n            // tie-breaker: pick the higher index first (center-right preference)\r\n            if (idx > closestIndex) closestIndex = idx;\r\n          }\r\n        }\r\n        out.push(closestIndex);\r\n        const removeIdx = candidates.indexOf(closestIndex);\r\n        if (removeIdx !== -1) candidates.splice(removeIdx, 1);\r\n      }\r\n      return out;\r\n    },\r\n    [text]\r\n  );\r\n\r\n  // scramble all non-space chars randomly\r\n  const scrambleAll = useCallback(\r\n    (source) => {\r\n      const chars = charsArrayRef.current;\r\n      return source\r\n        .split('')\r\n        .map((ch) => (ch === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]))\r\n        .join('');\r\n    },\r\n    []\r\n  );\r\n\r\n  // build the current display string from scrambledSetRef (for sequential mode)\r\n  const buildFromScrambledSet = useCallback(() => {\r\n    const s = scrambledSetRef.current;\r\n    const chars = charsArrayRef.current;\r\n    return text\r\n      .split('')\r\n      .map((ch, i) => {\r\n        if (ch === ' ') return ' ';\r\n        if (s.has(i)) {\r\n          return chars[Math.floor(Math.random() * chars.length)];\r\n        }\r\n        return ch;\r\n      })\r\n      .join('');\r\n  }, [text]);\r\n\r\n  // when text changes, recompute orders and reset state\r\n  useEffect(() => {\r\n    clearInterval(intervalRef.current);\r\n    scrambledSetRef.current = new Set();\r\n    encryptOrderRef.current = computeOrderForDirection(encryptDirection);\r\n    decryptOrderRef.current = computeOrderForDirection(decryptDirection);\r\n    encryptPointerRef.current = 0;\r\n    decryptPointerRef.current = 0;\r\n    setDisplayText(text);\r\n    setIsAnimating(false);\r\n    return () => clearInterval(intervalRef.current);\r\n  }, [text, computeOrderForDirection, encryptDirection, decryptDirection]);\r\n\r\n  // main animation effect\r\n  useEffect(() => {\r\n    clearInterval(intervalRef.current);\r\n    let iteration = 0;\r\n\r\n    if (isHovering) {\r\n      // ENCRYPT\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // sequential encryption: step through encryptOrderRef\r\n        intervalRef.current = setInterval(() => {\r\n          const order = encryptOrderRef.current;\r\n          const ptr = encryptPointerRef.current;\r\n\r\n          if (ptr >= order.length) {\r\n            // fully scrambled\r\n            setDisplayText(scrambleAll(text));\r\n            clearInterval(intervalRef.current);\r\n            return;\r\n          }\r\n\r\n          const idx = order[ptr];\r\n          scrambledSetRef.current.add(idx);\r\n          encryptPointerRef.current = ptr + 1;\r\n          setDisplayText(buildFromScrambledSet());\r\n\r\n          // Stop when all non-space indices scrambled\r\n          if (encryptPointerRef.current >= order.length) {\r\n            clearInterval(intervalRef.current);\r\n          }\r\n        }, speed);\r\n      } else {\r\n        // non-sequential: randomize whole text each tick, stop after maxIterations\r\n        intervalRef.current = setInterval(() => {\r\n          setDisplayText(scrambleAll(text));\r\n          iteration++;\r\n          if (iteration >= maxIterations) {\r\n            clearInterval(intervalRef.current);\r\n            setDisplayText(scrambleAll(text));\r\n          }\r\n        }, speed);\r\n      }\r\n    } else {\r\n      // DECRYPT (mouse leave)\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // sequential decryption: reveal indices per decryptOrderRef\r\n        intervalRef.current = setInterval(() => {\r\n          const order = decryptOrderRef.current;\r\n          // find next index in order that is currently scrambled\r\n          let found = -1;\r\n          while (decryptPointerRef.current < order.length) {\r\n            const cand = order[decryptPointerRef.current];\r\n            decryptPointerRef.current += 1;\r\n            if (scrambledSetRef.current.has(cand)) {\r\n              found = cand;\r\n              break;\r\n            }\r\n            // otherwise skip\r\n          }\r\n\r\n          if (found === -1) {\r\n            // no scrambled indices left in the rest of order; as fallback, remove any remaining scrambled indices\r\n            const anyLeft = Array.from(scrambledSetRef.current)[0];\r\n            if (anyLeft === undefined) {\r\n              // done\r\n              setDisplayText(text);\r\n              setIsAnimating(false);\r\n              clearInterval(intervalRef.current);\r\n              return;\r\n            }\r\n            scrambledSetRef.current.delete(anyLeft);\r\n            setDisplayText(buildFromScrambledSet());\r\n            return;\r\n          }\r\n\r\n          // reveal the found index (i.e., remove from scrambled set)\r\n          scrambledSetRef.current.delete(found);\r\n          setDisplayText(buildFromScrambledSet());\r\n\r\n          // if no scrambled indices left, finish\r\n          if (scrambledSetRef.current.size === 0) {\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n            clearInterval(intervalRef.current);\r\n          }\r\n        }, speed);\r\n      } else {\r\n        // non-sequential decrypt: randomize for a few iterations then reveal final\r\n        intervalRef.current = setInterval(() => {\r\n          iteration++;\r\n          if (iteration >= Math.ceil(maxIterations / 2)) {\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n            clearInterval(intervalRef.current);\r\n          } else {\r\n            setDisplayText(scrambleAll(text));\r\n          }\r\n        }, speed);\r\n      }\r\n    }\r\n\r\n    return () => clearInterval(intervalRef.current);\r\n  }, [isHovering, speed, maxIterations, sequential, scrambleAll, buildFromScrambledSet, text]);\r\n\r\n  return (\r\n    <motion.span\r\n      className={`wrapper ${className}`}\r\n      onMouseEnter={() => {\r\n        // reset decrypt pointer so decrypt scanning starts from beginning of decrypt order\r\n        decryptPointerRef.current = 0;\r\n        setIsHovering(true);\r\n      }}\r\n      onMouseLeave={() => {\r\n        // reset encrypt pointer so encrypt resumes from where it ended (or start)\r\n        encryptPointerRef.current = Math.min(encryptPointerRef.current, encryptOrderRef.current.length);\r\n        setIsHovering(false);\r\n      }}\r\n      {...props}\r\n    >\r\n      <span className=\"srOnly\" aria-hidden=\"true\">\r\n        {text}\r\n      </span>\r\n\r\n      <span aria-hidden=\"true\">\r\n        {displayText.split('').map((char, i) => {\r\n          const currentlyEncrypted = isAnimating && (sequential ? scrambledSetRef.current.has(i) : isHovering);\r\n          const usedClass = currentlyEncrypted ? encryptedClassName : className;\r\n          return (\r\n            <span key={i} className={usedClass} style={{ transition: 'color 0.25s ease' }}>\r\n              {char}\r\n            </span>\r\n          );\r\n        })}\r\n      </span>\r\n    </motion.span>\r\n  );\r\n};\r\n\r\nEncryptText.propTypes = {\r\n  text: PropTypes.string.isRequired,\r\n  speed: PropTypes.number,\r\n  maxIterations: PropTypes.number,\r\n  characters: PropTypes.string,\r\n  className: PropTypes.string,\r\n  encryptedClassName: PropTypes.string,\r\n  sequential: PropTypes.bool,\r\n  encryptDirection: PropTypes.oneOf(['start', 'end', 'center']),\r\n  decryptDirection: PropTypes.oneOf(['start', 'end', 'center']),\r\n};\r\n\r\nexport default EncryptText;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}