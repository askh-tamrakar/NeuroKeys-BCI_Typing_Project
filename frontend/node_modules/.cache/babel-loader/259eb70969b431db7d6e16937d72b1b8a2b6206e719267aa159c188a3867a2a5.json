{"ast":null,"code":"import _objectSpread from \"C:/Users/akmor/OneDrive/Projects/website/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"C:/Users/akmor/OneDrive/Projects/website/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// package.json\nvar version = \"1.3.11\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class Animate {\n  constructor() {\n    _defineProperty(this, \"isRunning\", false);\n    _defineProperty(this, \"value\", 0);\n    _defineProperty(this, \"from\", 0);\n    _defineProperty(this, \"to\", 0);\n    _defineProperty(this, \"currentTime\", 0);\n    // These are instanciated in the fromTo method\n    _defineProperty(this, \"lerp\", void 0);\n    _defineProperty(this, \"duration\", void 0);\n    _defineProperty(this, \"easing\", void 0);\n    _defineProperty(this, \"onUpdate\", void 0);\n  }\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    var _this$onUpdate;\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    (_this$onUpdate = this.onUpdate) === null || _this$onUpdate === void 0 || _this$onUpdate.call(this, this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, _ref) {\n    let {\n      lerp: lerp2,\n      duration,\n      easing,\n      onStart,\n      onUpdate\n    } = _ref;\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart === null || onStart === void 0 || onStart();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class Dimensions {\n  constructor(wrapper, content) {\n    let {\n      autoResize = true,\n      debounce: debounceValue = 250\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"scrollHeight\", 0);\n    _defineProperty(this, \"scrollWidth\", 0);\n    // These are instanciated in the constructor as they need information from the options\n    _defineProperty(this, \"debouncedResize\", void 0);\n    _defineProperty(this, \"wrapperResizeObserver\", void 0);\n    _defineProperty(this, \"contentResizeObserver\", void 0);\n    _defineProperty(this, \"resize\", () => {\n      this.onWrapperResize();\n      this.onContentResize();\n    });\n    _defineProperty(this, \"onWrapperResize\", () => {\n      if (this.wrapper instanceof Window) {\n        this.width = window.innerWidth;\n        this.height = window.innerHeight;\n      } else {\n        this.width = this.wrapper.clientWidth;\n        this.height = this.wrapper.clientHeight;\n      }\n    });\n    _defineProperty(this, \"onContentResize\", () => {\n      if (this.wrapper instanceof Window) {\n        this.scrollHeight = this.content.scrollHeight;\n        this.scrollWidth = this.content.scrollWidth;\n      } else {\n        this.scrollHeight = this.wrapper.scrollHeight;\n        this.scrollWidth = this.wrapper.scrollWidth;\n      }\n    });\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var _this$wrapperResizeOb, _this$contentResizeOb;\n    (_this$wrapperResizeOb = this.wrapperResizeObserver) === null || _this$wrapperResizeOb === void 0 || _this$wrapperResizeOb.disconnect();\n    (_this$contentResizeOb = this.contentResizeObserver) === null || _this$contentResizeOb === void 0 || _this$contentResizeOb.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class Emitter {\n  constructor() {\n    _defineProperty(this, \"events\", {});\n  }\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event) {\n    let callbacks = this.events[event] || [];\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      var _callbacks$i;\n      (_callbacks$i = callbacks[i]) === null || _callbacks$i === void 0 || _callbacks$i.call(callbacks, ...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    var _this$events$event;\n    ((_this$events$event = this.events[event]) === null || _this$events$event === void 0 ? void 0 : _this$events$event.push(cb)) || (this.events[event] = [cb]);\n    return () => {\n      var _this$events$event2;\n      this.events[event] = (_this$events$event2 = this.events[event]) === null || _this$events$event2 === void 0 ? void 0 : _this$events$event2.filter(i => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    var _this$events$event3;\n    this.events[event] = (_this$events$event3 = this.events[event]) === null || _this$events$event3 === void 0 ? void 0 : _this$events$event3.filter(i => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = {\n  passive: false\n};\nvar VirtualScroll = class VirtualScroll {\n  constructor(element) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      wheelMultiplier: 1,\n      touchMultiplier: 1\n    };\n    _defineProperty(this, \"touchStart\", {\n      x: 0,\n      y: 0\n    });\n    _defineProperty(this, \"lastDelta\", {\n      x: 0,\n      y: 0\n    });\n    _defineProperty(this, \"window\", {\n      width: 0,\n      height: 0\n    });\n    _defineProperty(this, \"emitter\", new Emitter());\n    /**\n     * Event handler for 'touchstart' event\n     *\n     * @param event Touch event\n     */\n    _defineProperty(this, \"onTouchStart\", event => {\n      const {\n        clientX,\n        clientY\n      } = event.targetTouches ? event.targetTouches[0] : event;\n      this.touchStart.x = clientX;\n      this.touchStart.y = clientY;\n      this.lastDelta = {\n        x: 0,\n        y: 0\n      };\n      this.emitter.emit(\"scroll\", {\n        deltaX: 0,\n        deltaY: 0,\n        event\n      });\n    });\n    /** Event handler for 'touchmove' event */\n    _defineProperty(this, \"onTouchMove\", event => {\n      const {\n        clientX,\n        clientY\n      } = event.targetTouches ? event.targetTouches[0] : event;\n      const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n      const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n      this.touchStart.x = clientX;\n      this.touchStart.y = clientY;\n      this.lastDelta = {\n        x: deltaX,\n        y: deltaY\n      };\n      this.emitter.emit(\"scroll\", {\n        deltaX,\n        deltaY,\n        event\n      });\n    });\n    _defineProperty(this, \"onTouchEnd\", event => {\n      this.emitter.emit(\"scroll\", {\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event\n      });\n    });\n    /** Event handler for 'wheel' event */\n    _defineProperty(this, \"onWheel\", event => {\n      let {\n        deltaX,\n        deltaY,\n        deltaMode\n      } = event;\n      const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n      const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n      deltaX *= multiplierX;\n      deltaY *= multiplierY;\n      deltaX *= this.options.wheelMultiplier;\n      deltaY *= this.options.wheelMultiplier;\n      this.emitter.emit(\"scroll\", {\n        deltaX,\n        deltaY,\n        event\n      });\n    });\n    _defineProperty(this, \"onWindowResize\", () => {\n      this.window = {\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n    });\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n    this.element.addEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n    this.element.removeEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n    this.element.removeEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n};\n\n// packages/core/src/lenis.ts\nvar defaultEasing = t => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class Lenis {\n  constructor() {\n    let {\n      wrapper = window,\n      content = document.documentElement,\n      eventsTarget = wrapper,\n      smoothWheel = true,\n      syncTouch = false,\n      syncTouchLerp = 0.075,\n      touchInertiaExponent = 1.7,\n      duration,\n      // in seconds\n      easing,\n      lerp: lerp2 = 0.1,\n      infinite = false,\n      orientation = \"vertical\",\n      // vertical, horizontal\n      gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\",\n      // vertical, horizontal, both\n      touchMultiplier = 1,\n      wheelMultiplier = 1,\n      autoResize = true,\n      prevent: _prevent,\n      virtualScroll,\n      overscroll = true,\n      autoRaf = false,\n      anchors = false,\n      autoToggle = false,\n      // https://caniuse.com/?search=transition-behavior\n      allowNestedScroll = false,\n      __experimental__naiveDimensions = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"_isScrolling\", false);\n    // true when scroll is animating\n    _defineProperty(this, \"_isStopped\", false);\n    // true if user should not be able to scroll - enable/disable programmatically\n    _defineProperty(this, \"_isLocked\", false);\n    // same as isStopped but enabled/disabled when scroll reaches target\n    _defineProperty(this, \"_preventNextNativeScrollEvent\", false);\n    _defineProperty(this, \"_resetVelocityTimeout\", null);\n    _defineProperty(this, \"__rafID\", null);\n    /**\n     * Whether or not the user is touching the screen\n     */\n    _defineProperty(this, \"isTouching\", void 0);\n    /**\n     * The time in ms since the lenis instance was created\n     */\n    _defineProperty(this, \"time\", 0);\n    /**\n     * User data that will be forwarded through the scroll event\n     *\n     * @example\n     * lenis.scrollTo(100, {\n     *   userData: {\n     *     foo: 'bar'\n     *   }\n     * })\n     */\n    _defineProperty(this, \"userData\", {});\n    /**\n     * The last velocity of the scroll\n     */\n    _defineProperty(this, \"lastVelocity\", 0);\n    /**\n     * The current velocity of the scroll\n     */\n    _defineProperty(this, \"velocity\", 0);\n    /**\n     * The direction of the scroll\n     */\n    _defineProperty(this, \"direction\", 0);\n    /**\n     * The options passed to the lenis instance\n     */\n    _defineProperty(this, \"options\", void 0);\n    /**\n     * The target scroll value\n     */\n    _defineProperty(this, \"targetScroll\", void 0);\n    /**\n     * The animated scroll value\n     */\n    _defineProperty(this, \"animatedScroll\", void 0);\n    // These are instanciated here as they don't need information from the options\n    _defineProperty(this, \"animate\", new Animate());\n    _defineProperty(this, \"emitter\", new Emitter());\n    // These are instanciated in the constructor as they need information from the options\n    _defineProperty(this, \"dimensions\", void 0);\n    // This is not private because it's used in the Snap class\n    _defineProperty(this, \"virtualScroll\", void 0);\n    _defineProperty(this, \"onScrollEnd\", e => {\n      if (!(e instanceof CustomEvent)) {\n        if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n          e.stopPropagation();\n        }\n      }\n    });\n    _defineProperty(this, \"dispatchScrollendEvent\", () => {\n      this.options.wrapper.dispatchEvent(new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      }));\n    });\n    _defineProperty(this, \"onTransitionEnd\", event => {\n      if (event.propertyName.includes(\"overflow\")) {\n        const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n        const overflow = getComputedStyle(this.rootElement)[property];\n        if ([\"hidden\", \"clip\"].includes(overflow)) {\n          this.internalStop();\n        } else {\n          this.internalStart();\n        }\n      }\n    });\n    _defineProperty(this, \"onClick\", event => {\n      const path = event.composedPath();\n      const anchor = path.find(node => {\n        var _node$getAttribute, _node$getAttribute2, _node$getAttribute3;\n        return node instanceof HTMLAnchorElement && (((_node$getAttribute = node.getAttribute(\"href\")) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.startsWith(\"#\")) || ((_node$getAttribute2 = node.getAttribute(\"href\")) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.startsWith(\"/#\")) || ((_node$getAttribute3 = node.getAttribute(\"href\")) === null || _node$getAttribute3 === void 0 ? void 0 : _node$getAttribute3.startsWith(\"./#\")));\n      });\n      if (anchor) {\n        const id = anchor.getAttribute(\"href\");\n        if (id) {\n          const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n          let target = \"#\".concat(id.split(\"#\")[1]);\n          if ([\"#\", \"/#\", \"./#\", \"#top\", \"/#top\", \"./#top\"].includes(id)) {\n            target = 0;\n          }\n          this.scrollTo(target, options);\n        }\n      }\n    });\n    _defineProperty(this, \"onPointerDown\", event => {\n      if (event.button === 1) {\n        this.reset();\n      }\n    });\n    _defineProperty(this, \"onVirtualScroll\", data => {\n      if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false) return;\n      const {\n        deltaX,\n        deltaY,\n        event\n      } = data;\n      this.emitter.emit(\"virtual-scroll\", {\n        deltaX,\n        deltaY,\n        event\n      });\n      if (event.ctrlKey) return;\n      if (event.lenisStopPropagation) return;\n      const isTouch = event.type.includes(\"touch\");\n      const isWheel = event.type.includes(\"wheel\");\n      this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n      const isClickOrTap = deltaX === 0 && deltaY === 0;\n      const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n      if (isTapToStop) {\n        this.reset();\n        return;\n      }\n      const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n      if (isClickOrTap || isUnknownGesture) {\n        return;\n      }\n      let composedPath = event.composedPath();\n      composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n      const prevent = this.options.prevent;\n      if (!!composedPath.find(node => {\n        var _node$hasAttribute, _node$hasAttribute2, _node$hasAttribute3;\n        return node instanceof HTMLElement && (typeof prevent === \"function\" && (prevent === null || prevent === void 0 ? void 0 : prevent(node)) || ((_node$hasAttribute = node.hasAttribute) === null || _node$hasAttribute === void 0 ? void 0 : _node$hasAttribute.call(node, \"data-lenis-prevent\")) || isTouch && ((_node$hasAttribute2 = node.hasAttribute) === null || _node$hasAttribute2 === void 0 ? void 0 : _node$hasAttribute2.call(node, \"data-lenis-prevent-touch\")) || isWheel && ((_node$hasAttribute3 = node.hasAttribute) === null || _node$hasAttribute3 === void 0 ? void 0 : _node$hasAttribute3.call(node, \"data-lenis-prevent-wheel\")) || this.options.allowNestedScroll && this.checkNestedScroll(node, {\n          deltaX,\n          deltaY\n        }));\n      })) return;\n      if (this.isStopped || this.isLocked) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n        return;\n      }\n      const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n      if (!isSmooth) {\n        this.isScrolling = \"native\";\n        this.animate.stop();\n        event.lenisStopPropagation = true;\n        return;\n      }\n      let delta = deltaY;\n      if (this.options.gestureOrientation === \"both\") {\n        delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n      } else if (this.options.gestureOrientation === \"horizontal\") {\n        delta = deltaX;\n      }\n      if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n        event.lenisStopPropagation = true;\n      }\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      const isSyncTouch = isTouch && this.options.syncTouch;\n      const isTouchEnd = isTouch && event.type === \"touchend\";\n      const hasTouchInertia = isTouchEnd;\n      if (hasTouchInertia) {\n        delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n      }\n      this.scrollTo(this.targetScroll + delta, _objectSpread({\n        programmatic: false\n      }, isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n        // immediate: !hasTouchInertia,\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }));\n    });\n    _defineProperty(this, \"onNativeScroll\", () => {\n      if (this._resetVelocityTimeout !== null) {\n        clearTimeout(this._resetVelocityTimeout);\n        this._resetVelocityTimeout = null;\n      }\n      if (this._preventNextNativeScrollEvent) {\n        this._preventNextNativeScrollEvent = false;\n        return;\n      }\n      if (this.isScrolling === false || this.isScrolling === \"native\") {\n        const lastScroll = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.lastVelocity = this.velocity;\n        this.velocity = this.animatedScroll - lastScroll;\n        this.direction = Math.sign(this.animatedScroll - lastScroll);\n        if (!this.isStopped) {\n          this.isScrolling = \"native\";\n        }\n        this.emit();\n        if (this.velocity !== 0) {\n          this._resetVelocityTimeout = setTimeout(() => {\n            this.lastVelocity = this.velocity;\n            this.velocity = 0;\n            this.isScrolling = false;\n            this.emit();\n          }, 400);\n        }\n      }\n    });\n    /**\n     * RequestAnimationFrame for lenis\n     *\n     * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n     */\n    _defineProperty(this, \"raf\", time => {\n      const deltaTime = time - (this.time || time);\n      this.time = time;\n      this.animate.advance(deltaTime * 1e-3);\n      if (this.options.autoRaf) {\n        this.__rafID = requestAnimationFrame(this.raf);\n      }\n    });\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent: _prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, {\n      autoResize\n    });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\"click\", this.onClick, false);\n    }\n    this.options.wrapper.addEventListener(\"pointerdown\", this.onPointerDown, false);\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\"pointerdown\", this.onPointerDown, false);\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\"click\", this.onClick, false);\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({\n        left: scroll,\n        behavior: \"instant\"\n      });\n    } else {\n      this.options.wrapper.scrollTo({\n        top: scroll,\n        behavior: \"instant\"\n      });\n    }\n  }\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty(\"overflow\");\n      return;\n    }\n    this.internalStart();\n  }\n  internalStart() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty(\"overflow\", \"clip\");\n      return;\n    }\n    this.internalStop();\n  }\n  internalStop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target) {\n    let {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp: lerp2 = this.options.lerp,\n      onStart,\n      onComplete,\n      force = false,\n      // scroll even if stopped\n      programmatic = true,\n      // called from outside of the class\n      userData\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      var _target;\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && (_target = target) !== null && _target !== void 0 && _target.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart === null || onStart === void 0 || onStart(this);\n      onComplete === null || onComplete === void 0 || onComplete(this);\n      return;\n    }\n    this.userData = userData !== null && userData !== void 0 ? userData : {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete === null || onComplete === void 0 || onComplete(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart === null || onStart === void 0 || onStart(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete === null || onComplete === void 0 || onComplete(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, _ref2) {\n    var _node$_lenis, _cache$time;\n    let {\n      deltaX,\n      deltaY\n    } = _ref2;\n    const time = Date.now();\n    const cache = (_node$_lenis = node._lenis) !== null && _node$_lenis !== void 0 ? _node$_lenis : node._lenis = {};\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - ((_cache$time = cache.time) !== null && _cache$time !== void 0 ? _cache$time : 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY) return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY)) return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX)) return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation) return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    var _wrapper$scrollX, _wrapper$scrollY;\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? (_wrapper$scrollX = wrapper.scrollX) !== null && _wrapper$scrollX !== void 0 ? _wrapper$scrollX : wrapper.scrollLeft : (_wrapper$scrollY = wrapper.scrollY) !== null && _wrapper$scrollY !== void 0 ? _wrapper$scrollY : wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle) className += \" lenis-autoToggle\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = \"\".concat(this.rootElement.className, \" \").concat(this.className).trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport { Lenis as default };","map":{"version":3,"names":["version","clamp","min","input","max","Math","lerp","x","y","t","damp","lambda","deltaTime","exp","modulo","n","d","Animate","constructor","_defineProperty","advance","_this$onUpdate","isRunning","completed","duration","easing","currentTime","linearProgress","easedProgress","value","from","to","round","stop","onUpdate","call","fromTo","_ref","lerp2","onStart","debounce","callback","delay","timer","_len","arguments","length","args","Array","_key","context","clearTimeout","setTimeout","apply","Dimensions","wrapper","content","autoResize","debounceValue","undefined","onWrapperResize","onContentResize","Window","width","window","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","debouncedResize","resize","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","_this$wrapperResizeOb","_this$contentResizeOb","disconnect","removeEventListener","limit","Emitter","emit","event","callbacks","events","_len2","_key2","i","_callbacks$i","on","cb","_this$events$event","push","_this$events$event2","filter","off","_this$events$event3","LINE_HEIGHT","listenerOptions","passive","VirtualScroll","element","options","wheelMultiplier","touchMultiplier","clientX","clientY","targetTouches","touchStart","lastDelta","emitter","deltaX","deltaY","deltaMode","multiplierX","multiplierY","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","defaultEasing","pow","Lenis","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaExponent","infinite","orientation","gestureOrientation","prevent","virtualScroll","overscroll","autoRaf","anchors","autoToggle","allowNestedScroll","__experimental__naiveDimensions","e","CustomEvent","isScrolling","stopPropagation","dispatchEvent","bubbles","detail","lenisScrollEnd","propertyName","includes","property","isHorizontal","overflow","getComputedStyle","rootElement","internalStop","internalStart","path","composedPath","anchor","find","node","_node$getAttribute","_node$getAttribute2","_node$getAttribute3","HTMLAnchorElement","getAttribute","startsWith","id","target","concat","split","scrollTo","button","reset","data","ctrlKey","lenisStopPropagation","isTouch","type","isWheel","isTouching","isClickOrTap","isTapToStop","isStopped","isLocked","isUnknownGesture","slice","indexOf","_node$hasAttribute","_node$hasAttribute2","_node$hasAttribute3","HTMLElement","hasAttribute","checkNestedScroll","cancelable","preventDefault","isSmooth","animate","delta","abs","animatedScroll","isSyncTouch","isTouchEnd","hasTouchInertia","sign","velocity","targetScroll","_objectSpread","programmatic","_resetVelocityTimeout","_preventNextNativeScrollEvent","lastScroll","actualScroll","lastVelocity","direction","time","__rafID","requestAnimationFrame","raf","lenisVersion","dimensions","updateClassName","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","onTransitionEnd","cleanUpClassName","cancelAnimationFrame","setScroll","scroll","left","behavior","top","start","style","removeProperty","setProperty","offset","immediate","lock","onComplete","force","userData","_target","querySelector","nodeType","wrapperRect","getBoundingClientRect","rect","distance","preventNextNativeScrollEvent","dispatchScrollendEvent","_ref2","_node$_lenis","_cache$time","Date","now","cache","_lenis","hasOverflowX","hasOverflowY","isScrollableX","isScrollableY","computedStyle","overflowXString","overflowX","overflowYString","overflowY","isScrollingX","isScrollingY","maxScroll","hasOverflow","isScrollable","scrollLeft","scrollTop","willScroll","_wrapper$scrollX","_wrapper$scrollY","scrollX","scrollY","progress","_isScrolling","_isStopped","_isLocked","className","trim","replace"],"sources":["C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\package.json","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\maths.ts","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\animate.ts","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\debounce.ts","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\dimensions.ts","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\emitter.ts","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\virtual-scroll.ts","C:\\Users\\akmor\\OneDrive\\Projects\\website\\node_modules\\lenis\\packages\\core\\src\\lenis.ts"],"sourcesContent":["{\n  \"name\": \"lenis\",\n  \"version\": \"1.3.11\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:dev\": \"npm publish --tag dev\",\n    \"publish:main\": \"npm publish\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\",\n    \"@nuxt/kit\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    },\n    \"@nuxt/kit\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./nuxt/runtime/*\": {\n      \"default\": \"./dist/nuxt/runtime/*.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n","/**\r\n * Clamp a value between a minimum and maximum value\r\n *\r\n * @param min Minimum value\r\n * @param input Value to clamp\r\n * @param max Maximum value\r\n * @returns Clamped value\r\n */\r\nexport function clamp(min: number, input: number, max: number) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n/**\r\n * Truncate a floating-point number to a specified number of decimal places\r\n *\r\n * @param value Value to truncate\r\n * @param decimals Number of decimal places to truncate to\r\n * @returns Truncated value\r\n */\r\nexport function truncate(value: number, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n/**\r\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\r\n *\r\n * @param x First value\r\n * @param y Second value\r\n * @param t Amount to interpolate (0 <= t <= 1)\r\n * @returns Interpolated value\r\n */\r\nexport function lerp(x: number, y: number, t: number) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n/**\r\n * Damp a value over time using a damping factor\r\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\r\n *\r\n * @param x Initial value\r\n * @param y Target value\r\n * @param lambda Damping factor\r\n * @param dt Time elapsed since the last update\r\n * @returns Damped value\r\n */\r\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\r\n}\r\n\r\n/**\r\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n * {@link https://anguscroll.com/just/just-modulo}\r\n *\r\n * @param n Dividend\r\n * @param d Divisor\r\n * @returns Modulo\r\n */\r\nexport function modulo(n: number, d: number) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\r\n\r\n/**\r\n * Animate class to handle value animations with lerping or easing\r\n *\r\n * @example\r\n * const animate = new Animate()\r\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\r\n * animate.advance(0.5) // 50\r\n */\r\nexport class Animate {\r\n  isRunning = false\r\n  value = 0\r\n  from = 0\r\n  to = 0\r\n  currentTime = 0\r\n\r\n  // These are instanciated in the fromTo method\r\n  lerp?: number\r\n  duration?: number\r\n  easing?: EasingFunction\r\n  onUpdate?: OnUpdateCallback\r\n\r\n  /**\r\n   * Advance the animation by the given delta time\r\n   *\r\n   * @param deltaTime - The time in seconds to advance the animation\r\n   */\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  /** Stop the animation */\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  /**\r\n   * Set up the animation from a starting value to an ending value\r\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\r\n   *\r\n   * @param from - The starting value\r\n   * @param to - The ending value\r\n   * @param options - Options for the animation\r\n   */\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","export function debounce<CB extends (...args: any[]) => void>(\r\n  callback: CB,\r\n  delay: number\r\n) {\r\n  let timer: number | undefined\r\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      timer = undefined\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\n/**\r\n * Dimensions class to handle the size of the content and wrapper\r\n *\r\n * @example\r\n * const dimensions = new Dimensions(wrapper, content)\r\n * dimensions.on('resize', (e) => {\r\n *   console.log(e.width, e.height)\r\n * })\r\n */\r\nexport class Dimensions {\r\n  width = 0\r\n  height = 0\r\n  scrollHeight = 0\r\n  scrollWidth = 0\r\n\r\n  // These are instanciated in the constructor as they need information from the options\r\n  private debouncedResize?: (...args: unknown[]) => void\r\n  private wrapperResizeObserver?: ResizeObserver\r\n  private contentResizeObserver?: ResizeObserver\r\n\r\n  constructor(\r\n    private wrapper: HTMLElement | Window | Element,\r\n    private content: HTMLElement | Element,\r\n    { autoResize = true, debounce: debounceValue = 250 } = {}\r\n  ) {\r\n    if (autoResize) {\r\n      this.debouncedResize = debounce(this.resize, debounceValue)\r\n\r\n      if (this.wrapper instanceof Window) {\r\n        window.addEventListener('resize', this.debouncedResize, false)\r\n      } else {\r\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n\r\n    if (this.wrapper === window && this.debouncedResize) {\r\n      window.removeEventListener('resize', this.debouncedResize, false)\r\n    }\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper instanceof Window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    if (this.wrapper instanceof Window) {\r\n      this.scrollHeight = this.content.scrollHeight\r\n      this.scrollWidth = this.content.scrollWidth\r\n    } else {\r\n      this.scrollHeight = this.wrapper.scrollHeight\r\n      this.scrollWidth = this.wrapper.scrollWidth\r\n    }\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Emitter class to handle events\r\n * @example\r\n * const emitter = new Emitter()\r\n * emitter.on('event', (data) => {\r\n *   console.log(data)\r\n * })\r\n * emitter.emit('event', 'data')\r\n */\r\nexport class Emitter {\r\n  private events: Record<\r\n    string,\r\n    Array<(...args: unknown[]) => void> | undefined\r\n  > = {}\r\n\r\n  /**\r\n   * Emit an event with the given data\r\n   * @param event Event name\r\n   * @param args Data to pass to the event handlers\r\n   */\r\n  emit(event: string, ...args: unknown[]) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i]?.(...args)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a callback to the event\r\n   * @param event Event name\r\n   * @param cb Callback function\r\n   * @returns Unsubscribe function\r\n   */\r\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback from the event\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  /**\r\n   * Remove all event listeners and clean up\r\n   */\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport type { VirtualScrollCallback } from './types'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\nconst listenerOptions: AddEventListenerOptions = { passive: false }\r\n\r\nexport class VirtualScroll {\r\n  touchStart = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  lastDelta = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  window = {\r\n    width: 0,\r\n    height: 0,\r\n  }\r\n  private emitter = new Emitter()\r\n\r\n  constructor(\r\n    private element: HTMLElement,\r\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\r\n  ) {\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\r\n  }\r\n\r\n  /**\r\n   * Add an event listener for the given event and callback\r\n   *\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  on(event: string, callback: VirtualScrollCallback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  /** Remove all event listeners and clean up */\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd,\r\n      listenerOptions\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Event handler for 'touchstart' event\r\n   *\r\n   * @param event Touch event\r\n   */\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'touchmove' event */\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'wheel' event */\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.options.wheelMultiplier\r\n    deltaY *= this.options.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.window = {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nconst defaultEasing = (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t))\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: ReturnType<typeof setTimeout> | null = null\n  private __rafID: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'easing' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration, // in seconds\n    easing,\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = orientation === 'horizontal' ? 'both' : 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    __experimental__naiveDimensions = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoToggle) {\n      this.rootElement.addEventListener('transitionend', this.onTransitionEnd, {\n        passive: true,\n      })\n    }\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  private onTransitionEnd = (event: TransitionEvent) => {\n    if (event.propertyName.includes('overflow')) {\n      const property = this.isHorizontal ? 'overflow-x' : 'overflow-y'\n\n      const overflow = getComputedStyle(this.rootElement)[\n        property as keyof CSSStyleDeclaration\n      ] as string\n\n      if (['hidden', 'clip'].includes(overflow)) {\n        this.internalStop()\n      } else {\n        this.internalStart()\n      }\n    }\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n    const anchor = path.find(\n      (node) =>\n        node instanceof HTMLAnchorElement &&\n        (node.getAttribute('href')?.startsWith('#') ||\n          node.getAttribute('href')?.startsWith('/#') ||\n          node.getAttribute('href')?.startsWith('./#'))\n    ) as HTMLAnchorElement | undefined\n    if (anchor) {\n      const id = anchor.getAttribute('href')\n\n      if (id) {\n        const options =\n          typeof this.options.anchors === 'object' && this.options.anchors\n            ? this.options.anchors\n            : undefined\n\n        let target: number | string = `#${id.split('#')[1]}`\n        if (['#', '/#', './#', '#top', '/#top', './#top'].includes(id)) {\n          target = 0\n        }\n\n        this.scrollTo(target, options)\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n            (this.options.allowNestedScroll &&\n              this.checkNestedScroll(node, { deltaX, deltaY })))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      }\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        this.limit > 0 &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    if (event.cancelable) {\n      event.preventDefault()\n    }\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd\n\n    if (hasTouchInertia) {\n      // delta = this.velocity * this.options.touchInertiaMultiplier\n      delta =\n        Math.sign(this.velocity) *\n        Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n            // immediate: !hasTouchInertia,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty('overflow')\n      return\n    }\n\n    this.internalStart()\n  }\n\n  private internalStart() {\n    if (!this.isStopped) return\n\n    this.reset()\n    this.isStopped = false\n    this.emit()\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty('overflow', 'clip')\n      return\n    }\n\n    this.internalStop()\n  }\n\n  private internalStop() {\n    if (this.isStopped) return\n\n    this.reset()\n    this.isStopped = true\n    this.emit()\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = this.options.lerp,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n\n        const distance = target - this.animatedScroll\n\n        if (distance > this.limit / 2) {\n          target = target - this.limit\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  private checkNestedScroll(\n    node: HTMLElement,\n    { deltaX, deltaY }: { deltaX: number; deltaY: number }\n  ) {\n    const time = Date.now()\n\n    // @ts-ignore\n    const cache = (node._lenis ??= {})\n\n    let hasOverflowX,\n      hasOverflowY,\n      isScrollableX,\n      isScrollableY,\n      scrollWidth,\n      scrollHeight,\n      clientWidth,\n      clientHeight\n\n    const gestureOrientation = this.options.gestureOrientation\n\n    if (time - (cache.time ?? 0) > 2000) {\n      cache.time = Date.now()\n\n      const computedStyle = window.getComputedStyle(node)\n      cache.computedStyle = computedStyle\n\n      const overflowXString = computedStyle.overflowX\n      const overflowYString = computedStyle.overflowY\n\n      hasOverflowX = ['auto', 'overlay', 'scroll'].includes(overflowXString)\n      hasOverflowY = ['auto', 'overlay', 'scroll'].includes(overflowYString)\n      cache.hasOverflowX = hasOverflowX\n      cache.hasOverflowY = hasOverflowY\n\n      if (!hasOverflowX && !hasOverflowY) return false // if no overflow, it's not scrollable no matter what, early return saves some computations\n      if (gestureOrientation === 'vertical' && !hasOverflowY) return false\n      if (gestureOrientation === 'horizontal' && !hasOverflowX) return false\n\n      scrollWidth = node.scrollWidth\n      scrollHeight = node.scrollHeight\n\n      clientWidth = node.clientWidth\n      clientHeight = node.clientHeight\n\n      isScrollableX = scrollWidth > clientWidth\n      isScrollableY = scrollHeight > clientHeight\n\n      cache.isScrollableX = isScrollableX\n      cache.isScrollableY = isScrollableY\n      cache.scrollWidth = scrollWidth\n      cache.scrollHeight = scrollHeight\n      cache.clientWidth = clientWidth\n      cache.clientHeight = clientHeight\n    } else {\n      isScrollableX = cache.isScrollableX\n      isScrollableY = cache.isScrollableY\n      hasOverflowX = cache.hasOverflowX\n      hasOverflowY = cache.hasOverflowY\n      scrollWidth = cache.scrollWidth\n      scrollHeight = cache.scrollHeight\n      clientWidth = cache.clientWidth\n      clientHeight = cache.clientHeight\n    }\n\n    if (\n      (!hasOverflowX && !hasOverflowY) ||\n      (!isScrollableX && !isScrollableY)\n    ) {\n      return false\n    }\n\n    if (gestureOrientation === 'vertical' && (!hasOverflowY || !isScrollableY))\n      return false\n\n    if (\n      gestureOrientation === 'horizontal' &&\n      (!hasOverflowX || !isScrollableX)\n    )\n      return false\n\n    let orientation: 'x' | 'y' | undefined\n\n    if (gestureOrientation === 'horizontal') {\n      orientation = 'x'\n    } else if (gestureOrientation === 'vertical') {\n      orientation = 'y'\n    } else {\n      const isScrollingX = deltaX !== 0\n      const isScrollingY = deltaY !== 0\n\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = 'x'\n      }\n\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = 'y'\n      }\n    }\n\n    if (!orientation) return false\n\n    let scroll, maxScroll, delta, hasOverflow, isScrollable\n\n    if (orientation === 'x') {\n      scroll = node.scrollLeft\n      maxScroll = scrollWidth - clientWidth\n      delta = deltaX\n\n      hasOverflow = hasOverflowX\n      isScrollable = isScrollableX\n    } else if (orientation === 'y') {\n      scroll = node.scrollTop\n      maxScroll = scrollHeight - clientHeight\n      delta = deltaY\n\n      hasOverflow = hasOverflowY\n      isScrollable = isScrollableY\n    } else {\n      return false\n    }\n\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0\n\n    return willScroll && hasOverflow && isScrollable\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.options.autoToggle) className += ' lenis-autoToggle'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}