{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\akmor\\\\OneDrive\\\\Projects\\\\website\\\\src\\\\components\\\\EncryptText.js\",\n  _s = $RefreshSig$();\n// src/components/EncryptText.js\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { motion } from 'motion/react';\nimport PropTypes from 'prop-types';\nimport './EncryptText.css';\n\n/**\r\n * EncryptText\r\n * - Hover to scramble (encrypt). Leave to revert (decrypt).\r\n * - Supports sequential (progressive) scrambling and independent directions for encrypt/decrypt.\r\n *\r\n * Fix: ensure animation restarts correctly on repeated hovers by resetting\r\n * refs/state on mouse enter and cleaning intervals reliably.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EncryptText = ({\n  text,\n  speed = 40,\n  maxIterations = 12,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\n  className = 'encrypt-text',\n  encryptedClassName = 'encrypted',\n  sequential = false,\n  encryptDirection = 'start',\n  // 'start' | 'end' | 'center'\n  decryptDirection = 'start',\n  // 'start' | 'end' | 'center'\n  ...props\n}) => {\n  _s();\n  const [displayText, setDisplayText] = useState(text);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  // refs to manage state across intervals without causing re-renders\n  const scrambledSetRef = useRef(new Set()); // indices that are currently scrambled\n  const intervalRef = useRef(null);\n  const charsArrayRef = useRef(characters.split(''));\n  const encryptOrderRef = useRef([]); // order for sequential encrypt\n  const decryptOrderRef = useRef([]); // order for sequential decrypt\n  const encryptPointerRef = useRef(0); // pointer into encrypt order\n  const decryptPointerRef = useRef(0); // pointer into decrypt order\n\n  // keep chars array updated\n  useEffect(() => {\n    charsArrayRef.current = characters.split('');\n  }, [characters]);\n\n  // produce index order for given direction (non-space indices)\n  const computeOrderForDirection = useCallback(dir => {\n    const len = text.length;\n    const indices = [];\n    for (let i = 0; i < len; i++) if (text[i] !== ' ') indices.push(i);\n    if (dir === 'start') return indices;\n    if (dir === 'end') return indices.slice().reverse();\n\n    // center: pick closest to middle first (tie -> right)\n    const out = [];\n    const middle = Math.floor(len / 2);\n    const candidates = indices.slice();\n    while (candidates.length) {\n      let closest = -1;\n      let bestDist = Infinity;\n      for (let idx of candidates) {\n        const dist = Math.abs(idx - middle);\n        if (dist < bestDist) {\n          bestDist = dist;\n          closest = idx;\n        } else if (dist === bestDist && idx > closest) {\n          // tie break prefer right side\n          closest = idx;\n        }\n      }\n      out.push(closest);\n      candidates.splice(candidates.indexOf(closest), 1);\n    }\n    return out;\n  }, [text]);\n\n  // scramble all non-space chars randomly\n  const scrambleAll = useCallback(source => {\n    const chars = charsArrayRef.current;\n    return source.split('').map(ch => ch === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]).join('');\n  }, []);\n\n  // build the string using scrambledSetRef (sequential mode)\n  const buildFromScrambledSet = useCallback(() => {\n    const s = scrambledSetRef.current;\n    const chars = charsArrayRef.current;\n    return text.split('').map((ch, i) => {\n      if (ch === ' ') return ' ';\n      if (s.has(i)) return chars[Math.floor(Math.random() * chars.length)];\n      return ch;\n    }).join('');\n  }, [text]);\n\n  // reset everything when text changes\n  useEffect(() => {\n    clearInterval(intervalRef.current);\n    scrambledSetRef.current = new Set();\n    encryptOrderRef.current = computeOrderForDirection(encryptDirection);\n    decryptOrderRef.current = computeOrderForDirection(decryptDirection);\n    encryptPointerRef.current = 0;\n    decryptPointerRef.current = 0;\n    setDisplayText(text);\n    setIsAnimating(false);\n    return () => clearInterval(intervalRef.current);\n  }, [text, computeOrderForDirection, encryptDirection, decryptDirection]);\n\n  // Ensure interval cleanup helper\n  const clearAnimInterval = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  }, []);\n\n  // Main animation effect depends on isHovering and other settings\n  useEffect(() => {\n    clearAnimInterval();\n    let iteration = 0;\n    if (isHovering) {\n      setIsAnimating(true);\n      if (sequential) {\n        // sequential encryption: step through encryptOrderRef\n        intervalRef.current = setInterval(() => {\n          const order = encryptOrderRef.current;\n          const ptr = encryptPointerRef.current;\n          if (ptr >= order.length) {\n            // fully scrambled\n            setDisplayText(scrambleAll(text));\n            clearAnimInterval();\n            return;\n          }\n          const idx = order[ptr];\n          scrambledSetRef.current.add(idx);\n          encryptPointerRef.current = ptr + 1;\n          setDisplayText(buildFromScrambledSet());\n          if (encryptPointerRef.current >= order.length) {\n            clearAnimInterval();\n          }\n        }, speed);\n      } else {\n        // non-sequential: randomize whole text each tick, stop after maxIterations\n        intervalRef.current = setInterval(() => {\n          setDisplayText(scrambleAll(text));\n          iteration++;\n          if (iteration >= maxIterations) {\n            clearAnimInterval();\n            setDisplayText(scrambleAll(text));\n          }\n        }, speed);\n      }\n    } else {\n      // decrypt (mouse leave)\n      setIsAnimating(true);\n      if (sequential) {\n        // sequential decryption: reveal based on decrypt order\n        intervalRef.current = setInterval(() => {\n          const order = decryptOrderRef.current;\n          // find next scrambled index according to decrypt order\n          let found = -1;\n          while (decryptPointerRef.current < order.length) {\n            const cand = order[decryptPointerRef.current];\n            decryptPointerRef.current++;\n            if (scrambledSetRef.current.has(cand)) {\n              found = cand;\n              break;\n            }\n          }\n          if (found === -1) {\n            // fallback: if nothing found, remove any remaining scrambled index\n            const anyLeft = Array.from(scrambledSetRef.current)[0];\n            if (anyLeft === undefined) {\n              setDisplayText(text);\n              setIsAnimating(false);\n              clearAnimInterval();\n              return;\n            }\n            scrambledSetRef.current.delete(anyLeft);\n            setDisplayText(buildFromScrambledSet());\n            return;\n          }\n          scrambledSetRef.current.delete(found);\n          setDisplayText(buildFromScrambledSet());\n          if (scrambledSetRef.current.size === 0) {\n            setDisplayText(text);\n            setIsAnimating(false);\n            clearAnimInterval();\n          }\n        }, speed);\n      } else {\n        // non-sequential decrypt: randomize few times then reveal\n        intervalRef.current = setInterval(() => {\n          iteration++;\n          if (iteration >= Math.ceil(maxIterations / 2)) {\n            setDisplayText(text);\n            setIsAnimating(false);\n            clearAnimInterval();\n          } else {\n            setDisplayText(scrambleAll(text));\n          }\n        }, speed);\n      }\n    }\n    return () => clearAnimInterval();\n  }, [isHovering, speed, maxIterations, sequential, scrambleAll, buildFromScrambledSet, clearAnimInterval, text]);\n\n  // NEW: handlers that reset refs/state so repeated hovers animate correctly\n  const handleMouseEnter = () => {\n    clearAnimInterval();\n    // Reset scrambled set & pointers so the animation starts fresh\n    scrambledSetRef.current = new Set();\n    encryptOrderRef.current = computeOrderForDirection(encryptDirection);\n    decryptOrderRef.current = computeOrderForDirection(decryptDirection);\n    encryptPointerRef.current = 0;\n    decryptPointerRef.current = 0;\n    // Ensure starting from original text to animate into scrambled\n    setDisplayText(text);\n    setIsAnimating(true);\n    setIsHovering(true);\n  };\n  const handleMouseLeave = () => {\n    clearAnimInterval();\n    // prepare decrypt pointers, don't fully reset encrypt pointer so decrypt can reveal correctly\n    decryptPointerRef.current = 0;\n    setIsHovering(false);\n    // isAnimating will be cleared by effect when fully decrypted\n  };\n  return /*#__PURE__*/_jsxDEV(motion.span, {\n    className: `wrapper ${className}`,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    ...props,\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"srOnly\",\n      \"aria-hidden\": \"true\",\n      children: text\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      \"aria-hidden\": \"true\",\n      children: displayText.split('').map((char, i) => {\n        const currentlyEncrypted = isAnimating && (sequential ? scrambledSetRef.current.has(i) : isHovering);\n        const usedClass = currentlyEncrypted ? encryptedClassName : className;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: usedClass,\n          style: {\n            transition: 'color 0.25s ease'\n          },\n          children: char\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 267,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 252,\n    columnNumber: 5\n  }, this);\n};\n_s(EncryptText, \"H0NCF0u6e2SPFOYDhZyMTq1WRqQ=\");\n_c = EncryptText;\nEncryptText.propTypes = {\n  text: PropTypes.string.isRequired,\n  speed: PropTypes.number,\n  maxIterations: PropTypes.number,\n  characters: PropTypes.string,\n  className: PropTypes.string,\n  encryptedClassName: PropTypes.string,\n  sequential: PropTypes.bool,\n  encryptDirection: PropTypes.oneOf(['start', 'end', 'center']),\n  decryptDirection: PropTypes.oneOf(['start', 'end', 'center'])\n};\nexport default EncryptText;\nvar _c;\n$RefreshReg$(_c, \"EncryptText\");","map":{"version":3,"names":["React","useCallback","useEffect","useRef","useState","motion","PropTypes","jsxDEV","_jsxDEV","EncryptText","text","speed","maxIterations","characters","className","encryptedClassName","sequential","encryptDirection","decryptDirection","props","_s","displayText","setDisplayText","isHovering","setIsHovering","isAnimating","setIsAnimating","scrambledSetRef","Set","intervalRef","charsArrayRef","split","encryptOrderRef","decryptOrderRef","encryptPointerRef","decryptPointerRef","current","computeOrderForDirection","dir","len","length","indices","i","push","slice","reverse","out","middle","Math","floor","candidates","closest","bestDist","Infinity","idx","dist","abs","splice","indexOf","scrambleAll","source","chars","map","ch","random","join","buildFromScrambledSet","s","has","clearInterval","clearAnimInterval","iteration","setInterval","order","ptr","add","found","cand","anyLeft","Array","from","undefined","delete","size","ceil","handleMouseEnter","handleMouseLeave","span","onMouseEnter","onMouseLeave","children","fileName","_jsxFileName","lineNumber","columnNumber","char","currentlyEncrypted","usedClass","style","transition","_c","propTypes","string","isRequired","number","bool","oneOf","$RefreshReg$"],"sources":["C:/Users/akmor/OneDrive/Projects/website/src/components/EncryptText.js"],"sourcesContent":["// src/components/EncryptText.js\r\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { motion } from 'motion/react';\r\nimport PropTypes from 'prop-types';\r\nimport './EncryptText.css';\r\n\r\n/**\r\n * EncryptText\r\n * - Hover to scramble (encrypt). Leave to revert (decrypt).\r\n * - Supports sequential (progressive) scrambling and independent directions for encrypt/decrypt.\r\n *\r\n * Fix: ensure animation restarts correctly on repeated hovers by resetting\r\n * refs/state on mouse enter and cleaning intervals reliably.\r\n */\r\nconst EncryptText = ({\r\n  text,\r\n  speed = 40,\r\n  maxIterations = 12,\r\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\r\n  className = 'encrypt-text',\r\n  encryptedClassName = 'encrypted',\r\n  sequential = false,\r\n  encryptDirection = 'start', // 'start' | 'end' | 'center'\r\n  decryptDirection = 'start', // 'start' | 'end' | 'center'\r\n  ...props\r\n}) => {\r\n  const [displayText, setDisplayText] = useState(text);\r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n\r\n  // refs to manage state across intervals without causing re-renders\r\n  const scrambledSetRef = useRef(new Set()); // indices that are currently scrambled\r\n  const intervalRef = useRef(null);\r\n  const charsArrayRef = useRef(characters.split(''));\r\n  const encryptOrderRef = useRef([]); // order for sequential encrypt\r\n  const decryptOrderRef = useRef([]); // order for sequential decrypt\r\n  const encryptPointerRef = useRef(0); // pointer into encrypt order\r\n  const decryptPointerRef = useRef(0); // pointer into decrypt order\r\n\r\n  // keep chars array updated\r\n  useEffect(() => {\r\n    charsArrayRef.current = characters.split('');\r\n  }, [characters]);\r\n\r\n  // produce index order for given direction (non-space indices)\r\n  const computeOrderForDirection = useCallback(\r\n    (dir) => {\r\n      const len = text.length;\r\n      const indices = [];\r\n      for (let i = 0; i < len; i++) if (text[i] !== ' ') indices.push(i);\r\n\r\n      if (dir === 'start') return indices;\r\n      if (dir === 'end') return indices.slice().reverse();\r\n\r\n      // center: pick closest to middle first (tie -> right)\r\n      const out = [];\r\n      const middle = Math.floor(len / 2);\r\n      const candidates = indices.slice();\r\n      while (candidates.length) {\r\n        let closest = -1;\r\n        let bestDist = Infinity;\r\n        for (let idx of candidates) {\r\n          const dist = Math.abs(idx - middle);\r\n          if (dist < bestDist) {\r\n            bestDist = dist;\r\n            closest = idx;\r\n          } else if (dist === bestDist && idx > closest) {\r\n            // tie break prefer right side\r\n            closest = idx;\r\n          }\r\n        }\r\n        out.push(closest);\r\n        candidates.splice(candidates.indexOf(closest), 1);\r\n      }\r\n      return out;\r\n    },\r\n    [text]\r\n  );\r\n\r\n  // scramble all non-space chars randomly\r\n  const scrambleAll = useCallback(\r\n    (source) => {\r\n      const chars = charsArrayRef.current;\r\n      return source\r\n        .split('')\r\n        .map((ch) => (ch === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]))\r\n        .join('');\r\n    },\r\n    []\r\n  );\r\n\r\n  // build the string using scrambledSetRef (sequential mode)\r\n  const buildFromScrambledSet = useCallback(() => {\r\n    const s = scrambledSetRef.current;\r\n    const chars = charsArrayRef.current;\r\n    return text\r\n      .split('')\r\n      .map((ch, i) => {\r\n        if (ch === ' ') return ' ';\r\n        if (s.has(i)) return chars[Math.floor(Math.random() * chars.length)];\r\n        return ch;\r\n      })\r\n      .join('');\r\n  }, [text]);\r\n\r\n  // reset everything when text changes\r\n  useEffect(() => {\r\n    clearInterval(intervalRef.current);\r\n    scrambledSetRef.current = new Set();\r\n    encryptOrderRef.current = computeOrderForDirection(encryptDirection);\r\n    decryptOrderRef.current = computeOrderForDirection(decryptDirection);\r\n    encryptPointerRef.current = 0;\r\n    decryptPointerRef.current = 0;\r\n    setDisplayText(text);\r\n    setIsAnimating(false);\r\n    return () => clearInterval(intervalRef.current);\r\n  }, [text, computeOrderForDirection, encryptDirection, decryptDirection]);\r\n\r\n  // Ensure interval cleanup helper\r\n  const clearAnimInterval = useCallback(() => {\r\n    if (intervalRef.current) {\r\n      clearInterval(intervalRef.current);\r\n      intervalRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  // Main animation effect depends on isHovering and other settings\r\n  useEffect(() => {\r\n    clearAnimInterval();\r\n    let iteration = 0;\r\n\r\n    if (isHovering) {\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // sequential encryption: step through encryptOrderRef\r\n        intervalRef.current = setInterval(() => {\r\n          const order = encryptOrderRef.current;\r\n          const ptr = encryptPointerRef.current;\r\n\r\n          if (ptr >= order.length) {\r\n            // fully scrambled\r\n            setDisplayText(scrambleAll(text));\r\n            clearAnimInterval();\r\n            return;\r\n          }\r\n\r\n          const idx = order[ptr];\r\n          scrambledSetRef.current.add(idx);\r\n          encryptPointerRef.current = ptr + 1;\r\n          setDisplayText(buildFromScrambledSet());\r\n\r\n          if (encryptPointerRef.current >= order.length) {\r\n            clearAnimInterval();\r\n          }\r\n        }, speed);\r\n      } else {\r\n        // non-sequential: randomize whole text each tick, stop after maxIterations\r\n        intervalRef.current = setInterval(() => {\r\n          setDisplayText(scrambleAll(text));\r\n          iteration++;\r\n          if (iteration >= maxIterations) {\r\n            clearAnimInterval();\r\n            setDisplayText(scrambleAll(text));\r\n          }\r\n        }, speed);\r\n      }\r\n    } else {\r\n      // decrypt (mouse leave)\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // sequential decryption: reveal based on decrypt order\r\n        intervalRef.current = setInterval(() => {\r\n          const order = decryptOrderRef.current;\r\n          // find next scrambled index according to decrypt order\r\n          let found = -1;\r\n          while (decryptPointerRef.current < order.length) {\r\n            const cand = order[decryptPointerRef.current];\r\n            decryptPointerRef.current++;\r\n            if (scrambledSetRef.current.has(cand)) {\r\n              found = cand;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (found === -1) {\r\n            // fallback: if nothing found, remove any remaining scrambled index\r\n            const anyLeft = Array.from(scrambledSetRef.current)[0];\r\n            if (anyLeft === undefined) {\r\n              setDisplayText(text);\r\n              setIsAnimating(false);\r\n              clearAnimInterval();\r\n              return;\r\n            }\r\n            scrambledSetRef.current.delete(anyLeft);\r\n            setDisplayText(buildFromScrambledSet());\r\n            return;\r\n          }\r\n\r\n          scrambledSetRef.current.delete(found);\r\n          setDisplayText(buildFromScrambledSet());\r\n\r\n          if (scrambledSetRef.current.size === 0) {\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n            clearAnimInterval();\r\n          }\r\n        }, speed);\r\n      } else {\r\n        // non-sequential decrypt: randomize few times then reveal\r\n        intervalRef.current = setInterval(() => {\r\n          iteration++;\r\n          if (iteration >= Math.ceil(maxIterations / 2)) {\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n            clearAnimInterval();\r\n          } else {\r\n            setDisplayText(scrambleAll(text));\r\n          }\r\n        }, speed);\r\n      }\r\n    }\r\n\r\n    return () => clearAnimInterval();\r\n  }, [isHovering, speed, maxIterations, sequential, scrambleAll, buildFromScrambledSet, clearAnimInterval, text]);\r\n\r\n  // NEW: handlers that reset refs/state so repeated hovers animate correctly\r\n  const handleMouseEnter = () => {\r\n    clearAnimInterval();\r\n    // Reset scrambled set & pointers so the animation starts fresh\r\n    scrambledSetRef.current = new Set();\r\n    encryptOrderRef.current = computeOrderForDirection(encryptDirection);\r\n    decryptOrderRef.current = computeOrderForDirection(decryptDirection);\r\n    encryptPointerRef.current = 0;\r\n    decryptPointerRef.current = 0;\r\n    // Ensure starting from original text to animate into scrambled\r\n    setDisplayText(text);\r\n    setIsAnimating(true);\r\n    setIsHovering(true);\r\n  };\r\n\r\n  const handleMouseLeave = () => {\r\n    clearAnimInterval();\r\n    // prepare decrypt pointers, don't fully reset encrypt pointer so decrypt can reveal correctly\r\n    decryptPointerRef.current = 0;\r\n    setIsHovering(false);\r\n    // isAnimating will be cleared by effect when fully decrypted\r\n  };\r\n\r\n  return (\r\n    <motion.span\r\n      className={`wrapper ${className}`}\r\n      onMouseEnter={handleMouseEnter}\r\n      onMouseLeave={handleMouseLeave}\r\n      {...props}\r\n    >\r\n      <span className=\"srOnly\" aria-hidden=\"true\">\r\n        {text}\r\n      </span>\r\n\r\n      <span aria-hidden=\"true\">\r\n        {displayText.split('').map((char, i) => {\r\n          const currentlyEncrypted = isAnimating && (sequential ? scrambledSetRef.current.has(i) : isHovering);\r\n          const usedClass = currentlyEncrypted ? encryptedClassName : className;\r\n          return (\r\n            <span key={i} className={usedClass} style={{ transition: 'color 0.25s ease' }}>\r\n              {char}\r\n            </span>\r\n          );\r\n        })}\r\n      </span>\r\n    </motion.span>\r\n  );\r\n};\r\n\r\nEncryptText.propTypes = {\r\n  text: PropTypes.string.isRequired,\r\n  speed: PropTypes.number,\r\n  maxIterations: PropTypes.number,\r\n  characters: PropTypes.string,\r\n  className: PropTypes.string,\r\n  encryptedClassName: PropTypes.string,\r\n  sequential: PropTypes.bool,\r\n  encryptDirection: PropTypes.oneOf(['start', 'end', 'center']),\r\n  decryptDirection: PropTypes.oneOf(['start', 'end', 'center']),\r\n};\r\n\r\nexport default EncryptText;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}