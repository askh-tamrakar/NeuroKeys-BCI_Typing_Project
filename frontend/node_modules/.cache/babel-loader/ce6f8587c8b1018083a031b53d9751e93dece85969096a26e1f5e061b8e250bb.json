{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\akmor\\\\OneDrive\\\\Projects\\\\website\\\\src\\\\components\\\\EncryptText.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { motion } from 'motion/react';\nimport './EncryptText.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EncryptText = ({\n  text,\n  speed = 40,\n  maxIterations = 12,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\n  className = 'encrypt-text',\n  encryptedClassName = 'encrypted',\n  parentClassName = '',\n  revealDirection = 'start',\n  sequential = false,\n  useOriginalCharsOnly = false,\n  animateOn = 'hover',\n  ...props\n}) => {\n  _s();\n  const [displayText, setDisplayText] = useState(text);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [revealedIndices, setRevealedIndices] = useState(new Set());\n  const [hasAnimated, setHasAnimated] = useState(false);\n  const intervalRef = useRef(null);\n  const containerRef = useRef(null);\n  const iterationRef = useRef(0);\n\n  // Helper function to get random character\n  const getRandomChar = availableChars => {\n    return availableChars[Math.floor(Math.random() * availableChars.length)];\n  };\n\n  // Determine next index to reveal based on direction\n  const getNextIndex = (revealedSet, textLength) => {\n    switch (revealDirection) {\n      case 'start':\n        return revealedSet.size;\n      case 'end':\n        return textLength - 1 - revealedSet.size;\n      case 'center':\n        {\n          const middle = Math.floor(textLength / 2);\n          const offset = Math.floor(revealedSet.size / 2);\n          const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\n          if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\n            return nextIndex;\n          }\n          for (let i = 0; i < textLength; i++) {\n            if (!revealedSet.has(i)) return i;\n          }\n          return 0;\n        }\n      default:\n        return revealedSet.size;\n    }\n  };\n\n  // Shuffle text while preserving revealed characters\n  const shuffleText = (originalText, currentRevealed) => {\n    const availableChars = useOriginalCharsOnly ? Array.from(new Set(originalText.split(''))).filter(char => char !== ' ') : characters.split('');\n    if (useOriginalCharsOnly) {\n      const positions = originalText.split('').map((char, i) => ({\n        char,\n        isSpace: char === ' ',\n        index: i,\n        isRevealed: currentRevealed.has(i)\n      }));\n      const nonSpaceChars = positions.filter(p => !p.isSpace && !p.isRevealed).map(p => p.char);\n\n      // Fisher-Yates shuffle\n      for (let i = nonSpaceChars.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];\n      }\n      let charIndex = 0;\n      return positions.map(p => {\n        if (p.isSpace) return ' ';\n        if (p.isRevealed) return originalText[p.index];\n        return nonSpaceChars[charIndex++];\n      }).join('');\n    }\n    return originalText.split('').map((char, i) => {\n      if (char === ' ') return ' ';\n      if (currentRevealed.has(i)) return originalText[i];\n      return getRandomChar(availableChars);\n    }).join('');\n  };\n\n  // Main animation effect\n  useEffect(() => {\n    clearInterval(intervalRef.current);\n    iterationRef.current = 0;\n    if (isHovering) {\n      setIsAnimating(true);\n      if (sequential) {\n        // Sequential reveal animation\n        intervalRef.current = setInterval(() => {\n          setRevealedIndices(prevRevealed => {\n            if (prevRevealed.size < text.length) {\n              const nextIndex = getNextIndex(prevRevealed, text.length);\n              const newRevealed = new Set(prevRevealed);\n              newRevealed.add(nextIndex);\n              setDisplayText(shuffleText(text, newRevealed));\n              return newRevealed;\n            }\n            clearInterval(intervalRef.current);\n            setIsAnimating(false);\n            setDisplayText(text);\n            return prevRevealed;\n          });\n        }, speed);\n      } else {\n        // Scramble all characters animation\n        intervalRef.current = setInterval(() => {\n          iterationRef.current++;\n          setDisplayText(shuffleText(text, new Set()));\n          if (iterationRef.current >= maxIterations) {\n            clearInterval(intervalRef.current);\n            setDisplayText(text);\n            setIsAnimating(false);\n          }\n        }, speed);\n      }\n    } else {\n      // Decrypt on mouse leave\n      setIsAnimating(true);\n      const decryptIterations = Math.floor(maxIterations / 2);\n      intervalRef.current = setInterval(() => {\n        iterationRef.current++;\n        if (iterationRef.current >= decryptIterations) {\n          setDisplayText(text);\n          setRevealedIndices(new Set());\n          clearInterval(intervalRef.current);\n          setIsAnimating(false);\n        } else {\n          setDisplayText(shuffleText(text, new Set()));\n        }\n      }, speed);\n    }\n    return () => clearInterval(intervalRef.current);\n  }, [isHovering, text, speed, maxIterations, sequential, revealDirection, characters, useOriginalCharsOnly]);\n\n  // Intersection Observer for 'view' animation trigger\n  useEffect(() => {\n    if (animateOn !== 'view' && animateOn !== 'both') return;\n    const observerCallback = entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting && !hasAnimated) {\n          setIsHovering(true);\n          setHasAnimated(true);\n        }\n      });\n    };\n    const observerOptions = {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0.1\n    };\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [animateOn, hasAnimated]);\n  const hoverProps = animateOn === 'hover' || animateOn === 'both' ? {\n    onMouseEnter: () => setIsHovering(true),\n    onMouseLeave: () => setIsHovering(false)\n  } : {};\n  return /*#__PURE__*/_jsxDEV(motion.span, {\n    ref: containerRef,\n    className: `wrapper ${parentClassName}`,\n    ...hoverProps,\n    ...props,\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"srOnly\",\n      children: text\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      \"aria-hidden\": \"true\",\n      children: displayText.split('').map((char, index) => {\n        const isRevealed = revealedIndices.has(index) || !isAnimating || !isHovering;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: isRevealed ? className : encryptedClassName,\n          style: {\n            transition: 'color 0.3s ease'\n          },\n          children: char\n        }, `char-${index}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 206,\n    columnNumber: 5\n  }, this);\n};\n_s(EncryptText, \"QhyhslsF8SV7iDQu0eNdQ7fhXkE=\");\n_c = EncryptText;\nEncryptText.propTypes = {\n  text: PropTypes.string.isRequired,\n  speed: PropTypes.number,\n  maxIterations: PropTypes.number,\n  characters: PropTypes.string,\n  className: PropTypes.string,\n  encryptedClassName: PropTypes.string,\n  parentClassName: PropTypes.string,\n  revealDirection: PropTypes.oneOf(['start', 'end', 'center']),\n  sequential: PropTypes.bool,\n  useOriginalCharsOnly: PropTypes.bool,\n  animateOn: PropTypes.oneOf(['hover', 'view', 'both'])\n};\nEncryptText.defaultProps = {\n  speed: 40,\n  maxIterations: 12,\n  characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\n  className: 'encrypt-text',\n  encryptedClassName: 'encrypted',\n  parentClassName: '',\n  revealDirection: 'start',\n  sequential: false,\n  useOriginalCharsOnly: false,\n  animateOn: 'hover'\n};\nexport default EncryptText;\nvar _c;\n$RefreshReg$(_c, \"EncryptText\");","map":{"version":3,"names":["useEffect","useState","useRef","PropTypes","motion","jsxDEV","_jsxDEV","EncryptText","text","speed","maxIterations","characters","className","encryptedClassName","parentClassName","revealDirection","sequential","useOriginalCharsOnly","animateOn","props","_s","displayText","setDisplayText","isHovering","setIsHovering","isAnimating","setIsAnimating","revealedIndices","setRevealedIndices","Set","hasAnimated","setHasAnimated","intervalRef","containerRef","iterationRef","getRandomChar","availableChars","Math","floor","random","length","getNextIndex","revealedSet","textLength","size","middle","offset","nextIndex","has","i","shuffleText","originalText","currentRevealed","Array","from","split","filter","char","positions","map","isSpace","index","isRevealed","nonSpaceChars","p","j","charIndex","join","clearInterval","current","setInterval","prevRevealed","newRevealed","add","decryptIterations","observerCallback","entries","forEach","entry","isIntersecting","observerOptions","root","rootMargin","threshold","observer","IntersectionObserver","currentRef","observe","unobserve","hoverProps","onMouseEnter","onMouseLeave","span","ref","children","fileName","_jsxFileName","lineNumber","columnNumber","style","transition","_c","propTypes","string","isRequired","number","oneOf","bool","defaultProps","$RefreshReg$"],"sources":["C:/Users/akmor/OneDrive/Projects/website/src/components/EncryptText.js"],"sourcesContent":["import { useEffect, useState, useRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { motion } from 'motion/react';\r\nimport './EncryptText.css';\r\n\r\nconst EncryptText = ({\r\n  text,\r\n  speed = 40,\r\n  maxIterations = 12,\r\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\r\n  className = 'encrypt-text',\r\n  encryptedClassName = 'encrypted',\r\n  parentClassName = '',\r\n  revealDirection = 'start',\r\n  sequential = false,\r\n  useOriginalCharsOnly = false,\r\n  animateOn = 'hover',\r\n  ...props\r\n}) => {\r\n  const [displayText, setDisplayText] = useState(text);\r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n  const [revealedIndices, setRevealedIndices] = useState(new Set());\r\n  const [hasAnimated, setHasAnimated] = useState(false);\r\n  const intervalRef = useRef(null);\r\n  const containerRef = useRef(null);\r\n  const iterationRef = useRef(0);\r\n\r\n  // Helper function to get random character\r\n  const getRandomChar = (availableChars) => {\r\n    return availableChars[Math.floor(Math.random() * availableChars.length)];\r\n  };\r\n\r\n  // Determine next index to reveal based on direction\r\n  const getNextIndex = (revealedSet, textLength) => {\r\n    switch (revealDirection) {\r\n      case 'start':\r\n        return revealedSet.size;\r\n      case 'end':\r\n        return textLength - 1 - revealedSet.size;\r\n      case 'center': {\r\n        const middle = Math.floor(textLength / 2);\r\n        const offset = Math.floor(revealedSet.size / 2);\r\n        const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\r\n\r\n        if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\r\n          return nextIndex;\r\n        }\r\n\r\n        for (let i = 0; i < textLength; i++) {\r\n          if (!revealedSet.has(i)) return i;\r\n        }\r\n        return 0;\r\n      }\r\n      default:\r\n        return revealedSet.size;\r\n    }\r\n  };\r\n\r\n  // Shuffle text while preserving revealed characters\r\n  const shuffleText = (originalText, currentRevealed) => {\r\n    const availableChars = useOriginalCharsOnly\r\n      ? Array.from(new Set(originalText.split(''))).filter(char => char !== ' ')\r\n      : characters.split('');\r\n\r\n    if (useOriginalCharsOnly) {\r\n      const positions = originalText.split('').map((char, i) => ({\r\n        char,\r\n        isSpace: char === ' ',\r\n        index: i,\r\n        isRevealed: currentRevealed.has(i)\r\n      }));\r\n\r\n      const nonSpaceChars = positions\r\n        .filter(p => !p.isSpace && !p.isRevealed)\r\n        .map(p => p.char);\r\n\r\n      // Fisher-Yates shuffle\r\n      for (let i = nonSpaceChars.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];\r\n      }\r\n\r\n      let charIndex = 0;\r\n      return positions\r\n        .map(p => {\r\n          if (p.isSpace) return ' ';\r\n          if (p.isRevealed) return originalText[p.index];\r\n          return nonSpaceChars[charIndex++];\r\n        })\r\n        .join('');\r\n    }\r\n\r\n    return originalText\r\n      .split('')\r\n      .map((char, i) => {\r\n        if (char === ' ') return ' ';\r\n        if (currentRevealed.has(i)) return originalText[i];\r\n        return getRandomChar(availableChars);\r\n      })\r\n      .join('');\r\n  };\r\n\r\n  // Main animation effect\r\n  useEffect(() => {\r\n    clearInterval(intervalRef.current);\r\n    iterationRef.current = 0;\r\n\r\n    if (isHovering) {\r\n      setIsAnimating(true);\r\n\r\n      if (sequential) {\r\n        // Sequential reveal animation\r\n        intervalRef.current = setInterval(() => {\r\n          setRevealedIndices(prevRevealed => {\r\n            if (prevRevealed.size < text.length) {\r\n              const nextIndex = getNextIndex(prevRevealed, text.length);\r\n              const newRevealed = new Set(prevRevealed);\r\n              newRevealed.add(nextIndex);\r\n              setDisplayText(shuffleText(text, newRevealed));\r\n              return newRevealed;\r\n            }\r\n            clearInterval(intervalRef.current);\r\n            setIsAnimating(false);\r\n            setDisplayText(text);\r\n            return prevRevealed;\r\n          });\r\n        }, speed);\r\n      } else {\r\n        // Scramble all characters animation\r\n        intervalRef.current = setInterval(() => {\r\n          iterationRef.current++;\r\n          setDisplayText(shuffleText(text, new Set()));\r\n\r\n          if (iterationRef.current >= maxIterations) {\r\n            clearInterval(intervalRef.current);\r\n            setDisplayText(text);\r\n            setIsAnimating(false);\r\n          }\r\n        }, speed);\r\n      }\r\n    } else {\r\n      // Decrypt on mouse leave\r\n      setIsAnimating(true);\r\n      const decryptIterations = Math.floor(maxIterations / 2);\r\n\r\n      intervalRef.current = setInterval(() => {\r\n        iterationRef.current++;\r\n\r\n        if (iterationRef.current >= decryptIterations) {\r\n          setDisplayText(text);\r\n          setRevealedIndices(new Set());\r\n          clearInterval(intervalRef.current);\r\n          setIsAnimating(false);\r\n        } else {\r\n          setDisplayText(shuffleText(text, new Set()));\r\n        }\r\n      }, speed);\r\n    }\r\n\r\n    return () => clearInterval(intervalRef.current);\r\n  }, [isHovering, text, speed, maxIterations, sequential, revealDirection, characters, useOriginalCharsOnly]);\r\n\r\n  // Intersection Observer for 'view' animation trigger\r\n  useEffect(() => {\r\n    if (animateOn !== 'view' && animateOn !== 'both') return;\r\n\r\n    const observerCallback = entries => {\r\n      entries.forEach(entry => {\r\n        if (entry.isIntersecting && !hasAnimated) {\r\n          setIsHovering(true);\r\n          setHasAnimated(true);\r\n        }\r\n      });\r\n    };\r\n\r\n    const observerOptions = {\r\n      root: null,\r\n      rootMargin: '0px',\r\n      threshold: 0.1\r\n    };\r\n\r\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\r\n    const currentRef = containerRef.current;\r\n\r\n    if (currentRef) {\r\n      observer.observe(currentRef);\r\n    }\r\n\r\n    return () => {\r\n      if (currentRef) {\r\n        observer.unobserve(currentRef);\r\n      }\r\n    };\r\n  }, [animateOn, hasAnimated]);\r\n\r\n  const hoverProps =\r\n    animateOn === 'hover' || animateOn === 'both'\r\n      ? {\r\n          onMouseEnter: () => setIsHovering(true),\r\n          onMouseLeave: () => setIsHovering(false)\r\n        }\r\n      : {};\r\n\r\n  return (\r\n    <motion.span\r\n      ref={containerRef}\r\n      className={`wrapper ${parentClassName}`}\r\n      {...hoverProps}\r\n      {...props}\r\n    >\r\n      <span className=\"srOnly\">{text}</span>\r\n      <span aria-hidden=\"true\">\r\n        {displayText.split('').map((char, index) => {\r\n          const isRevealed = revealedIndices.has(index) || !isAnimating || !isHovering;\r\n\r\n          return (\r\n            <span\r\n              key={`char-${index}`}\r\n              className={isRevealed ? className : encryptedClassName}\r\n              style={{ transition: 'color 0.3s ease' }}\r\n            >\r\n              {char}\r\n            </span>\r\n          );\r\n        })}\r\n      </span>\r\n    </motion.span>\r\n  );\r\n};\r\n\r\nEncryptText.propTypes = {\r\n  text: PropTypes.string.isRequired,\r\n  speed: PropTypes.number,\r\n  maxIterations: PropTypes.number,\r\n  characters: PropTypes.string,\r\n  className: PropTypes.string,\r\n  encryptedClassName: PropTypes.string,\r\n  parentClassName: PropTypes.string,\r\n  revealDirection: PropTypes.oneOf(['start', 'end', 'center']),\r\n  sequential: PropTypes.bool,\r\n  useOriginalCharsOnly: PropTypes.bool,\r\n  animateOn: PropTypes.oneOf(['hover', 'view', 'both']),\r\n};\r\n\r\nEncryptText.defaultProps = {\r\n  speed: 40,\r\n  maxIterations: 12,\r\n  characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+',\r\n  className: 'encrypt-text',\r\n  encryptedClassName: 'encrypted',\r\n  parentClassName: '',\r\n  revealDirection: 'start',\r\n  sequential: false,\r\n  useOriginalCharsOnly: false,\r\n  animateOn: 'hover',\r\n};\r\n\r\nexport default EncryptText;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}