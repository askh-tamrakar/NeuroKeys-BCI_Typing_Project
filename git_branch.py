import os
import sys
import subprocess
from pathlib import Path


# Hierarchical branch structure
BRANCH_HIERARCHY = {
    "master": None,  # Base branch
    "develop": "master",  # Created from master
    
    # Category branches from develop
    "sensors": "develop",
    "backend": "develop",
    "frontend": "develop",
    "integration": "develop",
    
    # Feature branches from their category
    "feature/eeg-bandpass": "sensors",
    "feature/eog-blink-detection": "sensors",
    "feature/emg-envelope": "sensors",
    
    "feature/websocket-server": "backend",
    "feature/fusion-server": "backend",
    "feature/ml-training": "backend",
    
    "feature/live-charts": "frontend",
    "feature/command-visualizer": "frontend",
    "feature/device-config": "frontend",
    
    "feature/realtime-pipeline": "integration",
    "feature/chords-serial": "integration",
}


def run(cmd, repo):
    """Run a git command in the repo directory."""
    subprocess.run(cmd, cwd=repo, check=True)


def run_quiet(cmd, repo):
    """Run a git command quietly and return output."""
    result = subprocess.run(
        cmd, 
        cwd=repo, 
        capture_output=True, 
        text=True, 
        check=True
    )
    return result.stdout


def get_existing_branches(repo):
    """Get list of all existing local and remote branches."""
    result = subprocess.run(
        ["git", "branch", "--list", "--all"],
        cwd=repo,
        capture_output=True,
        text=True,
        check=True
    )
    
    branches = set()
    for line in result.stdout.splitlines():
        name = (
            line.replace("*", "")
                .strip()
                .replace("remotes/origin/", "")
        )
        if name and name != "HEAD":
            branches.add(name)
    
    return branches


def branch_exists_remote(repo, branch):
    """Check if branch exists on remote."""
    try:
        result = subprocess.run(
            ["git", "ls-remote", "--heads", "origin", branch],
            cwd=repo,
            capture_output=True,
            text=True,
            check=True
        )
        return bool(result.stdout.strip())
    except:
        return False


def create_branch_from_base(repo, branch_name, base_branch, existing_branches):
    """Create a new branch from a base branch."""
    
    # Ensure base branch exists
    if base_branch not in existing_branches:
        print(f"   ‚ö†Ô∏è  Base branch '{base_branch}' doesn't exist yet, will create it first")
        return False
    
    # Fetch latest from remote
    print(f"   üì• Fetching latest from remote...")
    run(["git", "fetch", "origin"], repo)
    
    # Checkout base branch
    print(f"   üîÄ Checking out base: {base_branch}")
    
    # Try to checkout from remote if it exists there
    if branch_exists_remote(repo, base_branch):
        try:
            run(["git", "checkout", "-B", base_branch, f"origin/{base_branch}"], repo)
        except:
            run(["git", "checkout", base_branch], repo)
    else:
        run(["git", "checkout", base_branch], repo)
    
    run(["git", "pull", "origin", base_branch], repo)
    
    # Create new branch
    print(f"   ‚ú® Creating: {branch_name}")
    run(["git", "checkout", "-b", branch_name], repo)
    
    # Add marker file
    marker_path = repo / f".branch_markers/{branch_name.replace('/', '_')}.md"
    marker_path.parent.mkdir(parents=True, exist_ok=True)
    
    marker_content = f"""# Branch: {branch_name}

**Base Branch:** {base_branch}  
**Created:** Auto-generated by branch setup script  
**Purpose:** {get_branch_purpose(branch_name)}

## Workflow

1. Make changes in this branch
2. Test locally
3. Push to remote: `git push origin {branch_name}`
4. Create PR to merge into: `{base_branch}`
"""
    
    marker_path.write_text(marker_content)
    
    # Commit marker
    run(["git", "add", str(marker_path.relative_to(repo))], repo)
    run(["git", "commit", "-m", f"Initialize {branch_name} branch"], repo)
    
    # Push to remote
    print(f"   ‚¨ÜÔ∏è  Pushing to remote...")
    run(["git", "push", "-u", "origin", branch_name], repo)
    
    return True


def get_branch_purpose(branch_name):
    """Get human-readable purpose for a branch."""
    purposes = {
        "master": "Production-ready releases only",
        "develop": "Main integration branch for all development",
        "sensors/": "Sensor hardware, acquisition, and preprocessing (EEG/EMG/EOG)",
        "backend/": "API server, WebSocket, ML models, and fusion logic",
        "frontend/": "React dashboard, UI components, and visualization",
        "integration/": "End-to-end testing and cross-component integration",
        "feature/eeg-bandpass": "EEG bandpass filter implementation (1-45Hz)",
        "feature/eog-blink-detection": "EOG blink detection algorithm",
        "feature/emg-envelope": "EMG envelope extraction",
        "feature/websocket-server": "Real-time WebSocket server implementation",
        "feature/fusion-server": "Multi-modal sensor fusion server",
        "feature/ml-training": "ML model training pipeline",
        "feature/live-charts": "Live signal visualization charts",
        "feature/command-visualizer": "BCI command recognition UI",
        "feature/device-config": "Device configuration interface",
        "feature/realtime-pipeline": "End-to-end real-time signal pipeline",
        "feature/chords-serial": "Chords serial port integration",
    }
    return purposes.get(branch_name, "Development branch")


def main():
    if len(sys.argv) < 2:
        print("Usage: python create_branches_hierarchy.py /path/to/repo")
        sys.exit(1)
    
    repo = Path(sys.argv[1]).resolve()
    if not (repo / ".git").exists():
        print("‚ùå Error: This directory is not a git repository.")
        sys.exit(1)
    
    print("üîç Checking existing branches...")
    existing_branches = get_existing_branches(repo)
    
    print("\nüìã Existing branches:")
    for b in sorted(existing_branches):
        print(f"   ‚úì {b}")
    
    print("\nüå≥ Creating branch hierarchy...")
    print("=" * 60)
    
    # Process branches in dependency order
    created_this_run = set()
    max_iterations = 5  # Prevent infinite loops
    iteration = 0
    
    while len(created_this_run) + len(existing_branches) < len(BRANCH_HIERARCHY) and iteration < max_iterations:
        iteration += 1
        print(f"\nüìç Pass {iteration}...")
        
        for branch_name, base_branch in BRANCH_HIERARCHY.items():
            # Skip if already exists
            if branch_name in existing_branches or branch_name in created_this_run:
                continue
            
            # Skip if no base (this shouldn't happen with our structure)
            if base_branch is None:
                if branch_name not in existing_branches:
                    print(f"\n‚ö†Ô∏è  {branch_name}")
                    print(f"   Base branch '{branch_name}' must exist. Please create it manually.")
                continue
            
            # Check if base exists
            if base_branch not in existing_branches and base_branch not in created_this_run:
                continue  # Will try again in next pass
            
            print(f"\nüî® {branch_name}")
            success = create_branch_from_base(repo, branch_name, base_branch, existing_branches | created_this_run)
            
            if success:
                created_this_run.add(branch_name)
    
    print("\n" + "=" * 60)
    print("‚úÖ Branch creation complete!")
    
    # Return to develop
    print("\nüîô Returning to develop branch...")
    try:
        run(["git", "checkout", "develop"], repo)
    except:
        run(["git", "checkout", "master"], repo)
    
    print("\nüìä Summary:")
    print(f"   Total branches in hierarchy: {len(BRANCH_HIERARCHY)}")
    print(f"   Already existed: {len(existing_branches)}")
    print(f"   Created in this run: {len(created_this_run)}")
    
    if created_this_run:
        print("\n‚ú® Newly created branches:")
        for b in sorted(created_this_run):
            print(f"   ‚Ä¢ {b}")
    
    print("\nüìñ Branch Structure:")
    print("""
    master
      ‚Üë
    develop
      ‚Üë
      ‚îú‚îÄ sensors/
      ‚îÇ   ‚îú‚îÄ feature/eeg-bandpass
      ‚îÇ   ‚îú‚îÄ feature/eog-blink-detection
      ‚îÇ   ‚îî‚îÄ feature/emg-envelope
      ‚îÇ
      ‚îú‚îÄ backend/
      ‚îÇ   ‚îú‚îÄ feature/websocket-server
      ‚îÇ   ‚îú‚îÄ feature/fusion-server
      ‚îÇ   ‚îî‚îÄ feature/ml-training
      ‚îÇ
      ‚îú‚îÄ frontend/
      ‚îÇ   ‚îú‚îÄ feature/live-charts
      ‚îÇ   ‚îú‚îÄ feature/command-visualizer
      ‚îÇ   ‚îî‚îÄ feature/device-config
      ‚îÇ
      ‚îî‚îÄ integration/
          ‚îú‚îÄ feature/realtime-pipeline
          ‚îî‚îÄ feature/chords-serial
    """)

if __name__ == "__main__":
    main()
