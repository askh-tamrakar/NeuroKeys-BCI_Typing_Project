"""
EMG Neuroscience Application (single-file)

Features:
- Load EMG from CSV (time, channel1, channel2, ...), or from NumPy .npz
- Preprocess: bandpass (20-450 Hz), optional notch 50/60 Hz
- Rectify and compute envelope (RMS or Hilbert)
- Detect muscle activation onsets using thresholding
- Compute common EMG features (RMS, MAV, ZC, SSC, WL)
- Plot interactive figures (matplotlib) and optional Streamlit web UI

Usage (CLI):
    python emg_app.py --file path/to/emg.csv

Usage (Streamlit UI):
    streamlit run emg_app.py

Dependencies:
- numpy
- scipy
- pandas
- matplotlib
- optional: streamlit

CSV format expected: first column time (seconds) or sample index; subsequent columns are channels with headers.

Author: Generated by GPT
"""

import argparse
import sys
import os
from typing import Tuple, Dict

import numpy as np
import pandas as pd
from scipy import signal
from scipy.signal import butter, filtfilt, iirnotch, hilbert
import matplotlib.pyplot as plt

# try optional import
try:
    import streamlit as st
    HAS_STREAMLIT = True
except Exception:
    HAS_STREAMLIT = False


#########################
# Utility & IO
#########################

def load_emg_csv(path: str) -> Tuple[np.ndarray, np.ndarray]:
    """Load a CSV with first column time (or index) and subsequent columns channels.
    Returns (t, data) where data is shape (n_samples, n_channels)
    """
    df = pd.read_csv(path)
    if df.shape[1] < 2:
        raise ValueError("CSV must have at least 2 columns: time (or index) and 1 channel")
    t = df.iloc[:, 0].values.astype(float)
    data = df.iloc[:, 1:].values.astype(float)
    return t, data


def infer_fs(t: np.ndarray) -> float:
    """Infer sampling frequency from time vector t (seconds)"""
    if t is None or len(t) < 2:
        raise ValueError("Time vector too short to infer sampling rate")
    dt = np.diff(t)
    median_dt = np.median(dt)
    if median_dt <= 0:
        raise ValueError("Non-increasing time vector")
    return 1.0 / median_dt


#########################
# Filters & preprocessing
#########################

def butter_bandpass(lowcut, highcut, fs, order=4):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a


def bandpass_filter(signal_in: np.ndarray, lowcut: float, highcut: float, fs: float, order=4) -> np.ndarray:
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    return filtfilt(b, a, signal_in)


def notch_filter(signal_in: np.ndarray, fs: float, notch_freq=50.0, q=30.0) -> np.ndarray:
    w0 = notch_freq / (fs / 2)
    b, a = iirnotch(w0, q)
    return filtfilt(b, a, signal_in)


def rectify(sig: np.ndarray) -> np.ndarray:
    return np.abs(sig)


def envelope_rms(sig: np.ndarray, window_ms: float, fs: float) -> np.ndarray:
    win_samples = max(1, int(round(window_ms * fs / 1000.0)))
    # moving RMS using convolution
    sq = sig ** 2
    window = np.ones(win_samples) / float(win_samples)
    mean_sq = np.convolve(sq, window, mode='same')
    return np.sqrt(mean_sq)


def envelope_hilbert(sig: np.ndarray) -> np.ndarray:
    analytic = hilbert(sig)
    return np.abs(analytic)


#########################
# Feature extraction
#########################

def compute_features(sig: np.ndarray, fs: float) -> Dict[str, float]:
    """Compute basic EMG features on a 1D signal segment or whole channel.
    Returns a dict with RMS, MAV (mean absolute value), WL (waveform length), ZC, SSC
    """
    features = {}
    features['mean'] = float(np.mean(sig))
    features['std'] = float(np.std(sig))
    features['rms'] = float(np.sqrt(np.mean(sig ** 2)))
    features['mav'] = float(np.mean(np.abs(sig)))
    features['wl'] = float(np.sum(np.abs(np.diff(sig))))

    # Zero crossings (with threshold to avoid noise counts)
    thr = 0.01 * (np.max(np.abs(sig)) + 1e-12)
    zc = np.sum(((sig[:-1] * sig[1:]) < 0) & (np.abs(sig[:-1] - sig[1:]) >= thr))
    features['zc'] = int(zc)

    # Slope sign changes
    diff1 = np.diff(sig)
    diff2 = np.diff(sig[:-1])  # approximate
    ssc = np.sum(((diff1[:-1] * diff1[1:]) < 0))
    features['ssc'] = int(ssc)

    return features


#########################
# Onset detection
#########################

def detect_onsets(sig_env: np.ndarray, fs: float, threshold_factor=3.0, min_duration_ms=50) -> np.ndarray:
    """Simple threshold-based onset detector. Returns boolean vector of activations.
    threshold_factor multiplies median absolute value of baseline.
    """
    baseline = np.median(sig_env)
    mad = np.median(np.abs(sig_env - baseline))
    threshold = baseline + threshold_factor * mad
    active = sig_env >= threshold
    # remove short events
    min_samples = max(1, int(round(min_duration_ms * fs / 1000.0)))
    # run-length encoding approach
    cleaned = active.copy()
    # find starts and ends
    dif = np.diff(np.concatenate(([0], active.astype(int), [0])))
    starts = np.where(dif == 1)[0]
    ends = np.where(dif == -1)[0]
    for s, e in zip(starts, ends):
        if (e - s) < min_samples:
            cleaned[s:e] = False
    return cleaned


#########################
# Plotting
#########################

def plot_channel(t: np.ndarray, raw: np.ndarray, filtered: np.ndarray, env: np.ndarray, activation: np.ndarray, channel_name='ch'):
    plt.figure(figsize=(12, 6))
    ax1 = plt.subplot(311)
    plt.plot(t, raw)
    plt.title(f"Raw EMG - {channel_name}")
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude')

    ax2 = plt.subplot(312, sharex=ax1)
    plt.plot(t, filtered)
    plt.title('Bandpassed')
    plt.ylabel('Amplitude')

    ax3 = plt.subplot(313, sharex=ax1)
    plt.plot(t, env)
    plt.fill_between(t, 0, env, where=activation, alpha=0.3)
    plt.title('Envelope & activation (shaded)')
    plt.xlabel('Time (s)')
    plt.tight_layout()
    plt.show()


#########################
# CLI and streamlit
#########################

def run_cli(args):
    t, data = load_emg_csv(args.file)
    fs = args.fs if args.fs is not None else infer_fs(t)
    print(f"Loaded {data.shape[1]} channels, {data.shape[0]} samples, fs={fs:.1f} Hz")

    lowcut = args.low
    highcut = args.high
    notch = args.notch

    for ch in range(data.shape[1]):
        sig = data[:, ch]
        filtered = bandpass_filter(sig, lowcut, highcut, fs)
        if notch is not None and notch > 0:
            filtered = notch_filter(filtered, fs, notch_freq=notch)
        env = envelope_rms(rectify(filtered), window_ms=args.envelope_ms, fs=fs)
        activation = detect_onsets(env, fs, threshold_factor=args.threshold, min_duration_ms=args.min_dur)
        feats = compute_features(filtered, fs)
        print(f"Channel {ch+1}: features: {feats}")
        if args.plot:
            plot_channel(t, sig, filtered, env, activation, channel_name=f'ch{ch+1}')


# Streamlit app UI

def streamlit_app():
    st.title('EMG Neuroscience App')
    st.write('Upload a CSV where first column is time (s) and subsequent columns are channels')

    uploaded = st.file_uploader('Upload EMG CSV', type=['csv'])
    st.sidebar.header('Preprocessing')
    lowcut = st.sidebar.number_input('Lowcut (Hz)', value=20.0, step=1.0)
    highcut = st.sidebar.number_input('Highcut (Hz)', value=450.0, step=1.0)
    notch_freq = st.sidebar.selectbox('Notch (Hz)', options=[None, 50.0, 60.0])
    envelope_ms = st.sidebar.slider('Envelope window (ms)', min_value=10, max_value=500, value=100)
    threshold = st.sidebar.slider('Threshold factor (MAD)', min_value=0.5, max_value=10.0, value=3.0)
    min_dur = st.sidebar.slider('Min activation (ms)', min_value=10, max_value=500, value=50)

    if uploaded is not None:
        # read into pandas
        df = pd.read_csv(uploaded)
        st.write('Preview')
        st.dataframe(df.head())
        t = df.iloc[:, 0].values.astype(float)
        data = df.iloc[:, 1:].values.astype(float)
        fs = infer_fs(t)
        st.write(f'Inferred sampling rate: {fs:.1f} Hz')

        ch = st.selectbox('Channel', options=list(range(data.shape[1])), format_func=lambda x: f'Channel {x+1}')
        sig = data[:, ch]
        filtered = bandpass_filter(sig, lowcut, highcut, fs)
        if notch_freq is not None:
            filtered = notch_filter(filtered, fs, notch_freq=notch_freq)
        env = envelope_rms(rectify(filtered), window_ms=envelope_ms, fs=fs)
        activation = detect_onsets(env, fs, threshold_factor=threshold, min_duration_ms=min_dur)
        feats = compute_features(filtered, fs)

        st.subheader('Features')
        st.json(feats)

        st.subheader('Plots')
        fig, ax = plt.subplots(3, 1, figsize=(9, 6), sharex=True)
        ax[0].plot(t, sig)
        ax[0].set_title('Raw')
        ax[1].plot(t, filtered)
        ax[1].set_title('Filtered')
        ax[2].plot(t, env)
        ax[2].fill_between(t, 0, env, where=activation, alpha=0.3)
        ax[2].set_title('Envelope & activation')
        ax[2].set_xlabel('Time (s)')
        st.pyplot(fig)


#########################
# Entry point
#########################

def main():
    parser = argparse.ArgumentParser(description='EMG neuroscience single-file app')
    parser.add_argument('--file', type=str, help='Path to EMG CSV file')
    parser.add_argument('--fs', type=float, default=None, help='Sampling frequency (Hz) override')
    parser.add_argument('--low', type=float, default=20.0, help='Bandpass lowcut (Hz)')
    parser.add_argument('--high', type=float, default=450.0, help='Bandpass highcut (Hz)')
    parser.add_argument('--notch', type=float, default=50.0, help='Notch frequency (Hz); set 0 or -1 to disable')
    parser.add_argument('--envelope-ms', dest='envelope_ms', type=float, default=100.0, help='Envelope window in ms')
    parser.add_argument('--threshold', type=float, default=3.0, help='Onset threshold factor (MAD multiplier)')
    parser.add_argument('--min-dur', dest='min_dur', type=float, default=50.0, help='Minimum activation duration (ms)')
    parser.add_argument('--plot', action='store_true', help='Show matplotlib plots')
    parser.add_argument('--streamlit', action='store_true', help='Run Streamlit UI (requires streamlit installed)')

    args = parser.parse_args()

    if args.streamlit:
        if not HAS_STREAMLIT:
            print('streamlit not installed. Install with `pip install streamlit`')
            sys.exit(1)
        # If streamlit requested, run app
        # Note: when running `streamlit run emg_app.py`, streamlit executes file top-to-bottom; calling streamlit_app() here
        # will run inside streamlit session
        streamlit_app()
        return

    if args.file is None:
        print('No file provided. Use --file path/to/emg.csv or use --streamlit for web UI')
        parser.print_help()
        sys.exit(1)

    run_cli(args)


if __name__ == '__main__':
    main()
